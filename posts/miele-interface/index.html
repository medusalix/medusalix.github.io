<!doctype html><html lang=en dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="en"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=theme-color><title>Reverse Engineering the Miele Diagnostic Interface &#183; Severin's Blog</title><meta name=title content="Reverse Engineering the Miele Diagnostic Interface &#183; Severin's Blog"><meta name=description content="Severin's personal blog"><meta name=keywords content="Reverse Engineering,Hardware,Miele,"><link rel=canonical href=https://medusalix.github.io/posts/miele-interface/><link type=text/css rel=stylesheet href=/css/main.bundle.min.550f5e074e441ccc2a2d484da680e5c1592f2ee43201a9afb2adc00d5d3cb13adaa8418c74611594ce520e924b8319f13dc0b08e571120d4828076dcc0984574.css integrity="sha512-VQ9eB05EHMwqLUhNpoDlwVkvLuQyAamvsq3ADV08sTraqEGMdGEVlM5SDpJLgxnxPcCwjlcRINSCgHbcwJhFdA=="><script type=text/javascript src=/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.a187118b41a60744310065c567365de85730c8495301d0ebae41810cc6f7a47432b1de7d4f3b11338959f1ac50c266be6b4b73acf6bf770016eb59b602cc1aa0.js integrity="sha512-oYcRi0GmB0QxAGXFZzZd6FcwyElTAdDrrkGBDMb3pHQysd59TzsRM4lZ8axQwma+a0tzrPa/dwAW61m2AswaoA==" data-copy=Copy data-copied=Copied></script><script src=/lib/zoom/zoom.min.umd.a527109b68c082a70f3697716dd72a9d5aa8b545cf800cecbbc7399f2ca6f6e0ce3e431f2062b48bbfa47c9ea42822714060bef309be073f49b9c0e30d318d7b.js integrity="sha512-pScQm2jAgqcPNpdxbdcqnVqotUXPgAzsu8c5nyym9uDOPkMfIGK0i7+kfJ6kKCJxQGC+8wm+Bz9JucDjDTGNew=="></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://medusalix.github.io/posts/miele-interface/"><meta property="og:site_name" content="Severin's Blog"><meta property="og:title" content="Reverse Engineering the Miele Diagnostic Interface"><meta property="og:description" content="Severin's personal blog"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-17T00:00:00+02:00"><meta property="article:modified_time" content="2025-07-17T00:00:00+02:00"><meta property="article:tag" content="Reverse Engineering"><meta property="article:tag" content="Hardware"><meta property="article:tag" content="Miele"><meta property="og:image" content="https://medusalix.github.io/posts/miele-interface/featured.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://medusalix.github.io/posts/miele-interface/featured.jpg"><meta name=twitter:title content="Reverse Engineering the Miele Diagnostic Interface"><meta name=twitter:description content="Severin's personal blog"><meta name=twitter:image content="https://medusalix.github.io/posts/miele-interface/featured.jpg"><meta property="og:image" content="https://medusalix.github.io/posts/miele-interface/featured.jpg"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"Reverse Engineering the Miele Diagnostic Interface","headline":"Reverse Engineering the Miele Diagnostic Interface","inLanguage":"en","url":"https:\/\/medusalix.github.io\/posts\/miele-interface\/","author":{"@type":"Person","name":"Severin von Wnuck-Lipinski"},"copyrightYear":"2025","dateCreated":"2025-07-17T00:00:00\u002b02:00","datePublished":"2025-07-17T00:00:00\u002b02:00","dateModified":"2025-07-17T00:00:00\u002b02:00","keywords":["Reverse Engineering","Hardware","Miele"],"mainEntityOfPage":"true","wordCount":"6423"}]</script><meta name=author content="Severin von Wnuck-Lipinski"><link href=https://github.com/medusalix rel=me><link href=https://www.linkedin.com/in/severin-von-wnuck rel=me><link href=https://mastodon.social/@Medusalix rel=me><script src=/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj+KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a></div><div class=min-h-[148px]></div><div class="fixed inset-x-0 pl-[24px] pr-[24px] bg-neutral dark:bg-neutral-800 z-100"><div class="relative max-w-[64rem] ml-auto mr-auto"><div class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3 pt-[2px] pr-0 pb-[3px] pl-0"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">Severin&rsquo;s Blog</a></nav><nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12"><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title=Posts>Posts</p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title="Search (/)">
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title="Search (/)">
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 md:hidden"><div id=menu-button class=block><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50 pt-[5px]"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li id=menu-close-button><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title=Posts>Posts</p></a></li></ul></div></div></div></div></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><figure><img class="w-full rounded-lg single_hero_round nozoom" alt="Reverse Engineering the Miele Diagnostic Interface" width=1200 height=900 src=/posts/miele-interface/featured_hu_f0a4f45753870a9c.jpg></figure><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Reverse Engineering the Miele Diagnostic Interface</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime=2025-07-17T00:00:00+02:00>17 July 2025</time><span class="px-2 text-primary-500">&#183;</span><span>6423 words</span><span class="px-2 text-primary-500">&#183;</span><span title="Reading time">31 mins</span></div><div class="flex flex-row flex-wrap items-center"><span class="mr-2 mt-[0.5rem]" onclick='return window.open("/tags/reverse-engineering/","_self"),!1'><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Reverse Engineering
</span></span></span><span class="mr-2 mt-[0.5rem]" onclick='return window.open("/tags/hardware/","_self"),!1'><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Hardware
</span></span></span><span class="mr-2 mt-[0.5rem]" onclick='return window.open("/tags/miele/","_self"),!1'><span class="flex cursor-pointer"><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Miele</span></span></span></div></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-[140px]"><details open id=TOCView class="toc-right mt-0 overflow-y-auto overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#discovering-the-diagnostic-interface>Discovering the diagnostic interface</a><ul><li><a href=#diagnostic-capabilities>Diagnostic capabilities</a></li><li><a href=#communication-hardware>Communication hardware</a></li><li><a href=#building-an-open-source-mdu>Building an open source MDU</a></li></ul></li><li><a href=#reverse-engineering-the-electronics>Reverse engineering the electronics</a><ul><li><a href=#key-components>Key components</a></li><li><a href=#power-up-troubles>Power-up troubles</a></li><li><a href=#dumping-the-eeprom-data>Dumping the EEPROM data</a></li><li><a href=#analyzing-the-firmware>Analyzing the firmware</a></li></ul></li><li><a href=#reverse-engineering-the-pc-interface>Reverse engineering the PC interface</a><ul><li><a href=#finding-a-different-attack-vector>Finding a different attack vector</a></li><li><a href=#leaking-the-secret-key>Leaking the secret key</a></li><li><a href=#unlocking-the-pc-interface>Unlocking the PC interface</a></li><li><a href=#dumping-the-full-memory-contents>Dumping the full memory contents</a></li></ul></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#discovering-the-diagnostic-interface>Discovering the diagnostic interface</a><ul><li><a href=#diagnostic-capabilities>Diagnostic capabilities</a></li><li><a href=#communication-hardware>Communication hardware</a></li><li><a href=#building-an-open-source-mdu>Building an open source MDU</a></li></ul></li><li><a href=#reverse-engineering-the-electronics>Reverse engineering the electronics</a><ul><li><a href=#key-components>Key components</a></li><li><a href=#power-up-troubles>Power-up troubles</a></li><li><a href=#dumping-the-eeprom-data>Dumping the EEPROM data</a></li><li><a href=#analyzing-the-firmware>Analyzing the firmware</a></li></ul></li><li><a href=#reverse-engineering-the-pc-interface>Reverse engineering the PC interface</a><ul><li><a href=#finding-a-different-attack-vector>Finding a different attack vector</a></li><li><a href=#leaking-the-secret-key>Leaking the secret key</a></li><li><a href=#unlocking-the-pc-interface>Unlocking the PC interface</a></li><li><a href=#dumping-the-full-memory-contents>Dumping the full memory contents</a></li></ul></li></ul></nav></div></details><script>(function(){"use strict";const n=.33,s="#TableOfContents",o=".anchor",i='a[href^="#"]',a="li ul",r="active";function c(e,t){const s=window.scrollY+window.innerHeight*t,o=[...document.querySelectorAll('#TableOfContents a[href^="#"]')],n=new Set(o.map(e=>e.getAttribute("href").substring(1)));for(let t=e.length-1;t>=0;t--){const o=e[t].getBoundingClientRect().top+window.scrollY;if(o<=s&&n.has(e[t].id))return e[t].id}return e.find(e=>n.has(e.id))?.id||""}function e({toc:e,anchors:t,links:n,scrollOffset:s,collapseInactive:o}){const i=c(t,s);if(!i)return;if(n.forEach(e=>{const t=e.getAttribute("href")===`#${i}`;if(e.classList.toggle(r,t),o){const n=e.closest("li")?.querySelector("ul");n&&(n.style.display=t?"":"none")}}),o){const n=e.querySelector(`a[href="#${CSS.escape(i)}"]`);let t=n;for(;t&&t!==e;)t.tagName==="UL"&&(t.style.display=""),t.tagName==="LI"&&t.querySelector("ul")?.style.setProperty("display",""),t=t.parentElement}}function t(){const t=document.querySelector(s);if(!t)return;const c=!1,l=[...document.querySelectorAll(o)],d=[...t.querySelectorAll(i)];c&&t.querySelectorAll(a).forEach(e=>e.style.display="none");const r={toc:t,anchors:l,links:d,scrollOffset:n,collapseInactive:c};window.addEventListener("scroll",()=>e(r),{passive:!0}),window.addEventListener("hashchange",()=>e(r),{passive:!0}),e(r)}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",t):t()})()</script></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="article-content max-w-prose mb-20"><p>A few weeks ago, my parent&rsquo;s old Miele washing machine suddenly stopped functioning. It seemed like the machine finally required some maintenance, considering that it had been in operation for almost 20 years without issues. Disassembling the appliance revealed a number of hoses connecting the different parts of the washing machine. Upon closer inspection, several of these hoses were almost completely blocked by the detergent residue that had accumulated over the past two decades. After cleaning all hoses, the appliance initially seemed to be working fine again. However, at the end of the washing cycle, the machine didn&rsquo;t start to spin up. According to multiple forum posts, this fault was most likely caused by the analog pressure sensor that determines the water level inside the drum. If the residual water doesn&rsquo;t fall under a certain level during the pumping cycle, the machine aborts the current washing program. The white sensor housing can be easily spotted in the bottom right corner of the machine&rsquo;s electronics board:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Analog pressure sensor mounted on PCB" srcset="/posts/miele-interface/w2446_pressure_sensor_hu_e14639655b16660a.jpg 330w,
/posts/miele-interface/w2446_pressure_sensor_hu_2bb6e9bedb65fe51.jpg 660w,
/posts/miele-interface/w2446_pressure_sensor_hu_65fafc8944e86e5d.jpg 1280w" data-zoom-src=/posts/miele-interface/w2446_pressure_sensor.jpg src=/posts/miele-interface/w2446_pressure_sensor.jpg><figcaption>Analog pressure sensor mounted on PCB</figcaption></figure></p><p>Following some quick measurements with a multimeter, I determined that the sensor was functioning correctly. However, as several Miele experts pointed out, the sensor might have to be calibrated again after taking the machine apart, requiring a proprietary Miele software that is only available to registered service technicians. Fortunately, it turned out that this specific problem was not related to the calibration but could be instead fixed by clearing the machine&rsquo;s fault memory.</p><p>Even though the washing machine was now working again, I was still curious about how the pressure sensor could actually be calibrated. As far as I could tell, there were no external ports on the electronics board for programming purposes. <strong>So how does the Miele software communicate with the appliance?</strong></p><div class="flex px-4 py-3 rounded-md bg-primary-100 dark:bg-primary-900"><span class="text-primary-400 ltr:pr-3 rtl:pl-3 flex items-center"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M256 0C114.6.0.0 114.6.0 256s114.6 256 256 256 256-114.6 256-256S397.4.0 256 0zm0 128c17.67.0 32 14.33 32 32 0 17.67-14.33 32-32 32s-32-14.3-32-32 14.3-32 32-32zm40 256h-80c-13.2.0-24-10.7-24-24s10.75-24 24-24h16v-64h-8c-13.25.0-24-10.75-24-24s10.8-24 24-24h32c13.25.0 24 10.75 24 24v88h16c13.25.0 24 10.75 24 24s-10.7 24-24 24z"/></svg>
</span></span><span class=dark:text-neutral-300>This article turned out to be much longer than initially expected. Feel free to jump to individual sections if you want to skip some of the theory!</span></div><h2 class="relative group">Discovering the diagnostic interface<div id=discovering-the-diagnostic-interface class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#discovering-the-diagnostic-interface aria-label=Anchor>#</a></span></h2><p>Online repair guides and technical documentation often mention the so-called <strong>Miele Diagnostic Utility (MDU)</strong>, a proprietary tool used by technicians to diagnose common faults on all kinds of Miele devices. While every official repair business can register on Miele&rsquo;s website to get access to the service utility, its use requires very costly special hardware that has to be purchased from Miele and dedicated training sessions.</p><p>At first glance, very little information can be found online about the MDU, except for a few <a href="https://web.archive.org/web/20250716102841/https://forum.electronicwerkstatt.de/phpBB/jpg2.php?b_datei=26240_1218295661file1_Screen_MDU_W_2241" target=_blank>screenshots</a> of the software. For illustrative purposes, I came up with the following (very rough) sketch of the graphical user interface:</p><p><figure><img class="my-0 rounded-md" loading=lazy alt="User interface of the MDU (simplified sketch)" src=/posts/miele-interface/mdu_gui.svg><figcaption>User interface of the MDU (simplified sketch)</figcaption></figure></p><p>While looking for more details of the software, I discovered this <a href=https://genie-electrique.ac-versailles.fr/IMG/pdf/presetation_mieleprofs__bacprosen20012014clichy.pdf target=_blank>presentation</a> (in French) about an older version of Miele&rsquo;s diagnostic software and hardware, offering deeper insights into the capabilities and workings of the interface.</p><h3 class="relative group">Diagnostic capabilities<div id=diagnostic-capabilities class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#diagnostic-capabilities aria-label=Anchor>#</a></span></h3><p>Judging from the contents of the presentation, the MDU can be used to <strong>read various properties</strong> from a connected appliance. This includes the software ID, model and fabrication number, operating hours and fault memory. However, the number of properties that can be queried seems to vary from model to model.</p><p>While this data might be interesting for technically inclined appliance owners, the real power of the MDU lies in the monitoring features of the software. In addition to the <strong>live status of all sensors</strong> connected to the washing machine, such as the temperature sensor, water level sensor, or motor RPM, the utility also provides an overview of the <strong>actuator status</strong>, including all heating, water control and pump relays. The selected washing program and <strong>current program phase</strong> are also displayed by the software, along with the configured options, such as prewash or increased water level.</p><p>Many Miele washing machines provide a <strong>service mode</strong> that can be accessed by turning on the machine while pressing a certain button combination on the front panel. The service options offered by this mode can also be triggered by the MDU. However, the software additionally features a <strong>calibration menu</strong> that is used to calibrate internal sensors like the analog pressure sensor that measures the water level.</p><p>Finally, the MDU also provides <strong>program updates</strong> for Miele appliances. These updates were originally intended to allow changes to the built-in washing programs, such as adjusting program cycle times or the water amount. On newer appliances, the MDU can even update the full firmware of the electronics board.</p><h3 class="relative group">Communication hardware<div id=communication-hardware class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#communication-hardware aria-label=Anchor>#</a></span></h3><p>These features are highly useful for diagnostic purposes, not only for professional service technicians but also for appliance owners that would like to repair their own devices. But how does the MDU communicate with a Miele appliance? Reading through the presentation slides reveals a so-called <strong>Program Correction (PC)</strong> interface that is available on all appliances manufactured since 1996. This interface is located on the front panel of the machine, usually disguised as the <em>check inlet</em> indicator on washing machines or the <em>salt missing</em> indicator on dishwashers. The following picture clearly shows the PC interface on a Miele Softtronic W 2446 washing machine:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Front panel of Miele Softtronic W 2446 washing machine" srcset="/posts/miele-interface/w2446_front_panel_hu_e9f6ce0b60dd5f23.jpg 330w,
/posts/miele-interface/w2446_front_panel_hu_9b4da6ba2780b4ed.jpg 660w,
/posts/miele-interface/w2446_front_panel_hu_b7ab730dc63e629b.jpg 1280w" data-zoom-src=/posts/miele-interface/w2446_front_panel.jpg src=/posts/miele-interface/w2446_front_panel.jpg><figcaption>Front panel of Miele Softtronic W 2446 washing machine</figcaption></figure></p><p>While these indicator lights normally show the operating status of the machine, they are not just regular LEDs. Instead, the PC indicator LED also includes an infrared phototransistor, enabling bidirectional communication with the MDU software using a suitable optical communication adapter. According to a <a href=http://www.tie.ro/wp-content/uploads/2013/05/Smart_electronics_in_home_appliances_-_MIELE_-_TIE2013.pdf target=_blank>public Miele presentation</a>, this interface is not only used for field diagnostics, but also during the development phase and end-of-line factory testing. The presentation also includes a picture of the actual surface-mount LED that is used on the appliance side, which looks very similar to the <a href=https://ams-osram.com/products/leds/multi-color-leds/osram-multi-topled-sfh-7250 target=_blank>OSRAM Multi TOPLED SFH 7250</a> at first glance. While a dual-use indicator is clever in principle, it comes with drawbacks. When the respective indicator light is actually in use, no communication via the PC interface is possible. For this reason, Miele might have decided to switch to a dedicated PC LED indicator on newer appliances, such as their coffee machines. Due to the close proximity between the emitter and phototransistor, the communication is also limited to a relatively slow half-duplex operation.</p><p>Practical use of the MDU software requires a proprietary optical communication adapter, which has to be purchased separately from Miele. This adapter, which is also referred to as the <strong>Miele Optical Interface</strong>, consists of an interface box (codename EZI 820) and a head unit (EZI 821-A) that are connected via a fiber-optic cable. The interface box features a DE-9 connector for RS-232 communication with a host PC. Newer versions of the optical interface also include a USB connector for this purpose. The head unit is then attached to the appliance through a suction cup mechanism, aligning an optical fiber with the PC indicator hole. This complete assembly and communication technique has been <a href="https://depatisnet.dpma.de/DepatisNet/depatisnet?action=bibdat&amp;docid=DE000019544371A1" target=_blank>patented</a> by Miele in 1995, with the original intention of allowing washing program corrections for after-sales service.</p><p>Due to the proprietary nature of the optical interface, Miele does not publish any images of the adapter unit. However, given the high cost of official hardware, these adapters often surface on auction sites with <a href=https://web.archive.org/web/20250612145846/https://www.ebay.de/itm/336001153888 target=_blank>detailed pictures</a>. Some people are even <a href=https://www.elektroda.com/rtvforum/topic3462883.html target=_blank>looking to buy</a> the MDU from other sources, as the adapter is pretty much useless without the software.</p><h3 class="relative group">Building an open source MDU<div id=building-an-open-source-mdu class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#building-an-open-source-mdu aria-label=Anchor>#</a></span></h3><p>While not many details are available online about the internals of the Miele Optical Interface, <a href=https://community.symcon.de/t/miele-at-home-erweiterung/38651/14 target=_blank>this forum user</a> claims to have bought the unit from an eBay auction. The adapter is apparently a simple serial to infrared converter, implementing the well-known Infrared Data Association (IrDA) standard, commonly used in older laptops and embedded systems. It is based on an STM32F103 microcontroller, with all upper level protocol logic implemented by the MDU software. This is excellent news, as building an adapter would therefore only require a cheap microcontroller and an infrared emitter/detector.</p><p>In contrast to the details about the adapter unit, the proprietary protocol that is used by the MDU software is completely undocumented. However, reverse engineering the protocol would allow an open source diagnostic software to be built, which would be immensely useful for the repair community. It might also allow older Miele appliances to be integrated into home automation solutions, by building a bridge between the PC interface and existing software such as Home Assistant.</p><h2 class="relative group">Reverse engineering the electronics<div id=reverse-engineering-the-electronics class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#reverse-engineering-the-electronics aria-label=Anchor>#</a></span></h2><p>With these goals in mind, I decided to look for salvaged electronics from old Miele appliances on eBay. More specifically, I was looking for the main circuit board of a washing machine, since experimenting on a fully assembled appliance would have posed significant electrical and mechanical hazards. As luck would have it, I managed to win the bid for a brand new <strong>Miele EDPW 206</strong> manufactured in 2010:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Front side of Miele EDPW 206 electronics board" srcset="/posts/miele-interface/edpw_front_hu_954129e24955a5de.jpg 330w,
/posts/miele-interface/edpw_front_hu_20f713a39952de7c.jpg 660w,
/posts/miele-interface/edpw_front_hu_3b8abe6837cff55d.jpg 1280w" data-zoom-src=/posts/miele-interface/edpw_front.jpg src=/posts/miele-interface/edpw_front.jpg><figcaption>Front side of Miele EDPW 206 electronics board</figcaption></figure></p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Back side of Miele EDPW 206 electronics board" srcset="/posts/miele-interface/edpw_back_hu_375d0a85bb0e05f.jpg 330w,
/posts/miele-interface/edpw_back_hu_ce3143cf383ef1ac.jpg 660w,
/posts/miele-interface/edpw_back_hu_516bd676fd809440.jpg 1280w" data-zoom-src=/posts/miele-interface/edpw_back.jpg src=/posts/miele-interface/edpw_back.jpg><figcaption>Back side of Miele EDPW 206 electronics board</figcaption></figure></p><p>This board is part of the Miele W 961 washing machine series, manufactured from 1998 to 2003, according to <a href="https://forum.teamhack.de/thread/71117-alte-miele-novotronic-w961-oder-was-neues/?postID=377287#post377287" target=_blank>this forum post</a>. The EDPW 200 label on the back side of the PCB hints at the existence of further variations of this board for other washing machines. In contrast to newer Miele appliances, the power electronics are contained on a separate PCB for this machine, making the reverse engineering process much safer.</p><p>The PCB itself is a pretty simple double-layer design, without any bigger copper fills. Ground and power traces are instead routed as separate tracks, leading to the enormous number of vias that can be seen in the previous pictures. Figuring out the connections between individual components is unfortunately pretty tedious for this reason.</p><h3 class="relative group">Key components<div id=key-components class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#key-components aria-label=Anchor>#</a></span></h3><p>One of the central components of this PCB is a large 80-pin chip marked with <code>MIELE 6478170 M37451MC-804FP</code>. A quick online search for M37451 suggests that this chip is part of the Mitsubishi 740 series of 8-bit microcontrollers, which are also known as MELPS 740, according to <a href=https://en.wikipedia.org/wiki/Mitsubishi_740 target=_blank>Wikipedia</a>. These microcontrollers were originally manufactured during the 1980s and 1990s, with a relatively simple instruction set similar to the widely known WDC 65C02. Although these parts are no longer produced today, the instruction set lives on in the newer Renesas 38000/740 microcontroller series.</p><p>The <code>M37451MC-804FP</code> includes an integrated mask ROM, meaning the Miele firmware is embedded directly in the chip’s die and can&rsquo;t be reprogrammed after the manufacturing process. As denoted by the <code>MC</code> suffix, the <code>M37451MC-804FP</code> has a total RAM size of 512 bytes with a 24 kB mask ROM. Other features include an 8-bit ADC with 8 channels, an 2-channel 8-bit DAC and three individual 16-bit timers. Serial communication is handled by a serial I/O block that can be configured for asynchronous or synchronous operation. The chip is powered by a 5 V supply, with an operating frequency of 10 MHz. More information about the Mitsubishi microcontrollers can be found in <a href=https://bitsavers.org/components/mitsubishi/melps/1992_Single-Chip_8_Bit_Microcomputers_Vol_2.pdf target=_blank>volume two of Mitsubishi&rsquo;s Single-Chip 8-bit Microcomputers Data Book</a>.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Mitsubishi M37451 microcontroller and Microchip 93LC66BI EEPROM" srcset="/posts/miele-interface/edpw_mcu_eeprom_hu_34aa5ce52602517a.jpg 330w,
/posts/miele-interface/edpw_mcu_eeprom_hu_24dedce2edc67d4d.jpg 660w,
/posts/miele-interface/edpw_mcu_eeprom_hu_2ffec1b9635552dd.jpg 1280w" data-zoom-src=/posts/miele-interface/edpw_mcu_eeprom.jpg src=/posts/miele-interface/edpw_mcu_eeprom.jpg><figcaption>Mitsubishi M37451 microcontroller and Microchip 93LC66BI EEPROM</figcaption></figure></p><p>Located right next to the microcontroller is a Microchip 93LC66BI EEPROM with a capacity of only 512 bytes. The stored data is organized in 16-bit words, which can be accessed via a Microwire interface. All configuration parameters and the current state of the running wash cycle are written to the EEPROM just before the machine is powered off. This allows the machine to resume the program once it is turned back on again. In addition to this data, the EEPROM also stores any program corrections that are applied via the PC interface.</p><p>As the water inlet, detergent processing and heating cycle are controlled by individual relays that require an input voltage higher than 5 V, the PCB also includes a Texas Instruments ULN2003A Darlington transistor array.</p><p>The water level inside the washing machine&rsquo;s drum is sensed by an SPX3078D analog pressure sensor manufactured by Motorola. This sensor basically consists of a silicon diaphragm, which is used to determine the applied pressure through a Wheatstone bridge circuit. The differential output voltage is then processed by an ELMOS E210.01C. Since ELMOS provides no public documentation on this component, its exact function is unclear. However, I strongly assume it contains an operational amplifier and possibly additional signal processing circuitry. One of the pins is connected to the microcontroller&rsquo;s analog input port and provides a voltage proportional to the sensed pressure.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Motorola SPX3078D pressure sensor, ELMOS E210.01C IC and TI ULN2003A transistor array" srcset="/posts/miele-interface/edpw_pressure_sensor_hu_fab12694a16dbab4.jpg 330w,
/posts/miele-interface/edpw_pressure_sensor_hu_836defc0a5c65819.jpg 660w,
/posts/miele-interface/edpw_pressure_sensor_hu_428f1a28e4610928.jpg 1280w" data-zoom-src=/posts/miele-interface/edpw_pressure_sensor.jpg src=/posts/miele-interface/edpw_pressure_sensor.jpg><figcaption>Motorola SPX3078D pressure sensor, ELMOS E210.01C IC and TI ULN2003A transistor array</figcaption></figure></p><p>Most of the indicator LEDs on the PCB are multiplexed and wired to a Motorola MC14489DW LED driver, which offers an SPI interface for the microcontroller:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Motorola MC14489DW LED driver" srcset="/posts/miele-interface/edpw_led_driver_hu_fe843d22b4e2bbf3.jpg 330w,
/posts/miele-interface/edpw_led_driver_hu_a59fcadd3fed6fdc.jpg 660w,
/posts/miele-interface/edpw_led_driver_hu_3346c2304e65443a.jpg 1280w" data-zoom-src=/posts/miele-interface/edpw_led_driver.jpg src=/posts/miele-interface/edpw_led_driver.jpg><figcaption>Motorola MC14489DW LED driver</figcaption></figure></p><p>Upon detailed inspection of the LEDs on the right side of the board, one can see that the lowest LED is quite different from the rest of the group. Looking closer reveals that this LED is actually a combined infrared emitter and phototransistor. This is the optical PC interface, disguised as one of the indicator lights:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Optical PC interface next to normal indicator LED" srcset="/posts/miele-interface/edpw_pc_led_hu_688dd5d2747a05aa.jpg 330w,
/posts/miele-interface/edpw_pc_led_hu_ae3c6ae17ae36470.jpg 660w,
/posts/miele-interface/edpw_pc_led_hu_682231b49f047960.jpg 1280w" data-zoom-src=/posts/miele-interface/edpw_pc_led.jpg src=/posts/miele-interface/edpw_pc_led.jpg><figcaption>Optical PC interface next to normal indicator LED</figcaption></figure></p><p>As noted in the <a href=#communication-hardware>communication hardware section</a>, this part looks very similar to the OSRAM Multi TOPLED SFH 7250. The PC LED is not part of the group of multiplexed LEDs and is instead wired to a pair of transistors. An NPN transistor connects the microcontroller&rsquo;s UART transmit pin to the light emitter, while the phototransistor is connected to the UART receive pin via a PNP transistor.</p><div class="lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl">The PC interface is therefore just a simple optical UART port, albeit limited to half-duplex communication.</div><h3 class="relative group">Power-up troubles<div id=power-up-troubles class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#power-up-troubles aria-label=Anchor>#</a></span></h3><p>To communicate with the EDPW board via the optical interface, the PCB has to be connected to an appropriate power supply. Luckily, the EDPW 206&rsquo;s technical documentation includes the complete pinout of the board&rsquo;s connectors:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="EDPW 206 connector pinout" srcset="/posts/miele-interface/edpw_pinout_hu_2157a79b5880063d.jpg 330w,
/posts/miele-interface/edpw_pinout_hu_4a680d8cc54a0a3a.jpg 660w,
/posts/miele-interface/edpw_pinout_hu_bf1c5aa6b1b81945.jpg 1280w" data-zoom-src=/posts/miele-interface/edpw_pinout.jpg src=/posts/miele-interface/edpw_pinout.jpg><figcaption>EDPW 206 connector pinout</figcaption></figure></p><p>However, simply supplying the board with 5 V from a lab power supply didn&rsquo;t seem to have any effect. Taking a closer look at the pinout shows that the board also expects 20 V for the U<sub>C</sub> voltage, which is connected to the ULN2003A&rsquo;s common-cathode node for the integrated flyback diodes. This voltage seems to be sensed by the microcontroller through a resistive divider. Unfortunately, even with those two voltages, the EDPW didn&rsquo;t seem to turn on. Further investigation revealed that the board also requires an AC zero-crossing detection signal, referred to by the term <strong>Netznulldurchgang (NND)</strong> in German. This signal is generated by an optocoupler on the power electronics board, resulting in an alternating wave based on the line frequency. Supplying a 50 Hz square wave from a Pi Pico in place of this signal finally brought the EDPW to life:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Working EDPW 206 board (with blinking red LEDs)" srcset="/posts/miele-interface/edpw_working_hu_283d86defb94a05.jpg 330w,
/posts/miele-interface/edpw_working_hu_520cc9f037734949.jpg 660w,
/posts/miele-interface/edpw_working_hu_3b53cb185036e85d.jpg 1280w" data-zoom-src=/posts/miele-interface/edpw_working.jpg src=/posts/miele-interface/edpw_working.jpg><figcaption>Working EDPW 206 board (with blinking red LEDs)</figcaption></figure></p><p>While all basic functions of the EDPW seemed to work fine, including the program selection knob and the configuration buttons, I quickly noticed that the <em>check intake</em> and <em>check drain</em> indicators were flashing. Because the <em>check intake</em> LED also serves as the optical interface, this issue had to be resolved before any communication was possible. I initially assumed that the analog pressure sensor was giving some incorrect readings, but further investigations ruled out this theory. Instead, this issue was related to the missing relays that would normally be connected to the board. As it turns out, the microcontroller actually checks the presence of the <em>prewash</em> and <em>main wash</em> relays by sensing the voltage on the board&rsquo;s relay outputs. When the relays are connected to U<sub>C</sub> on one side, the voltage at the transistor array&rsquo;s collector pins is also equal to U<sub>C</sub>. Both the <em>prewash</em> and <em>main wash</em> outputs then go to a BAV70 common cathode double diode chip that is wired to the microcontroller:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="BAV70 common cathode double diode (marked as A4W)" srcset="/posts/miele-interface/edpw_diode_hu_e4a1f2959c1a178e.jpg 330w,
/posts/miele-interface/edpw_diode_hu_383581d206c22e0d.jpg 660w,
/posts/miele-interface/edpw_diode_hu_c4c1fbc4ff8f61f3.jpg 1280w" data-zoom-src=/posts/miele-interface/edpw_diode.jpg src=/posts/miele-interface/edpw_diode.jpg><figcaption>BAV70 common cathode double diode (marked as A4W)</figcaption></figure></p><p>Connecting a 10 kOhm resistor between the pin for the <em>main wash</em> relay and U<sub>C</sub> therefore stops the red LEDs from blinking. With this workaround in place, the EDPW board was now fully functional.</p><h3 class="relative group">Dumping the EEPROM data<div id=dumping-the-eeprom-data class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#dumping-the-eeprom-data aria-label=Anchor>#</a></span></h3><p>Before reverse engineering the PC interface, it is worth taking a closer look at the EEPROM chip. Removing the chip from the PCB and soldering it to an SOIC adapter allows its contents to be read using a CH341A EEPROM programmer. It should be noted that the adapter can&rsquo;t be plugged into the socket directly, as the pinout of the 93XXX chip differs from classic 25XXX EEPROMs that this programmer is designed for.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Adapter PCB for SOIC EEPROM chips" srcset="/posts/miele-interface/eeprom_adapter_hu_d33a3372b5f54384.jpg 330w,
/posts/miele-interface/eeprom_adapter_hu_e1a47b10d4ac5cf1.jpg 660w,
/posts/miele-interface/eeprom_adapter_hu_f9aca2d405791daa.jpg 1280w" data-zoom-src=/posts/miele-interface/eeprom_adapter.jpg src=/posts/miele-interface/eeprom_adapter.jpg><figcaption>Adapter PCB for SOIC EEPROM chips</figcaption></figure></p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="CH341A EEPROM and flash programmer" srcset="/posts/miele-interface/eeprom_programmer_hu_945019af30e572a8.jpg 330w,
/posts/miele-interface/eeprom_programmer_hu_ce36e1382dcb96e8.jpg 660w,
/posts/miele-interface/eeprom_programmer_hu_f795449d9cb190f6.jpg 1280w" data-zoom-src=/posts/miele-interface/eeprom_programmer.jpg src=/posts/miele-interface/eeprom_programmer.jpg><figcaption>CH341A EEPROM and flash programmer</figcaption></figure></p><p>Reading the EEPROM contents with <a href=https://github.com/bigbigmdm/IMSProg target=_blank>IMSProg</a> revealed that only 42 bytes are actually used, with almost all remaining bytes set to <code>ff</code>, indicating erased or unused memory:</p><pre>
00000000  ff ff f0 ff ff ff cc fb  b0 55 fd ff ca ce f7 db
00000010  ff ff ff d3 fd ff ff ff  ff f7 fe f8 fe 11 f8 f8
00000020  f8 f8 f8 f8 f8 fa f8 f8  f8 63 ff ff ff ff ff ff
00000030  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff
*
000001f0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff 00
</pre><p>To analyze how the stored data changes under different washing program settings and conditions, the EEPROM chip was soldered to the PCB again, while also attaching a logic analyzer to monitor the Microwire interface:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="EDPW board with probes connected to EEPROM chip" srcset="/posts/miele-interface/edpw_eeprom_probes_hu_125c71f04af74147.jpg 330w,
/posts/miele-interface/edpw_eeprom_probes_hu_74e5f973c26025ff.jpg 660w,
/posts/miele-interface/edpw_eeprom_probes_hu_ed9d11c27c0fcb03.jpg 1280w" data-zoom-src=/posts/miele-interface/edpw_eeprom_probes.jpg src=/posts/miele-interface/edpw_eeprom_probes.jpg><figcaption>EDPW board with probes connected to EEPROM chip</figcaption></figure></p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="USB logic analyzer with 8 channels" srcset="/posts/miele-interface/logic_analyzer_hu_ce7f302171f0a5cf.jpg 330w,
/posts/miele-interface/logic_analyzer_hu_74dc6b3eedf738b.jpg 660w,
/posts/miele-interface/logic_analyzer_hu_6a41a2abd443f365.jpg 1280w" data-zoom-src=/posts/miele-interface/logic_analyzer.jpg src=/posts/miele-interface/logic_analyzer.jpg><figcaption>USB logic analyzer with 8 channels</figcaption></figure></p><p>When the EDPW board is powered on, the microcontroller reads the first 42 bytes from the EEPROM. As soon as either the U<sub>C</sub> voltage or the zero-crossing signal are lost, the memory contents are written back to the EEPROM.</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="EEPROM Microwire signal capture in PulseView" srcset="/posts/miele-interface/eeprom_microwire_hu_c2db60567c5cf0b3.png 330w,
/posts/miele-interface/eeprom_microwire_hu_fc241a7faa9e1471.png 660w,
/posts/miele-interface/eeprom_microwire_hu_7182353c29309764.png 1280w" data-zoom-src=/posts/miele-interface/eeprom_microwire.png src=/posts/miele-interface/eeprom_microwire.png><figcaption>EEPROM Microwire signal capture in PulseView</figcaption></figure></p><p>After trying out different washing programs and observing the changes to the individual bytes, the full EEPROM contents can be deciphered:</p><pre>
00000000  <span class=highlight1>00 00 0f 00 00 00 33 04</span>  <span class=highlight1>4f aa 02 00 35 31 08 24</span>
00000010  <span class=highlight1>00 00 00</span> <span class=highlight2>2c</span> 02 00 00 00  <span class=highlight3>00 08 01 07 01</span> <span class=highlight2>ee</span> <span class=highlight4>07 07</span>
00000020  <span class=highlight4>07 07 07 07 07 05 07 07</span>  <span class=highlight4>07 9c</span> 00 00 00 00 00 00
00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
*
000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 ff
</pre><p>All bytes are inverted before being written to the EEPROM by the microcontroller. The <span class=highlight1>first 12 bytes</span> store general information about the washing machine. As an example, this includes the currently running program and program phase (first and second byte) and the operating hours of the appliance (third and fourth byte). This section ends with a simple <span class=highlight2>one byte checksum</span> that is computed by summing the preceding bytes (modulo <code>ff</code>) and inverting the result.</p><p>The next <span class=highlight3>group of bytes</span> encodes the fixed washing machine configuration that can only be changed by entering the programming mode. Settings such as the water type and region code are stored in this section. Another <span class=highlight2>checksum</span> is appended to these bytes, again computed over all previous bytes.</p><p>Configuration options that are chosen during the normal operation of the machine (e.g. short, prewash, spin cycle RPM, etc.) are preserved in the <span class=highlight4>subsequent bytes</span>, stored separately for each individual washing program.</p><p>The last section is mostly empty, but most likely used to further customize the behavior of washing programs as part of the program correction mechanism. Selecting the <em>Cottons 95 °C</em> program for example causes the microcontroller to continuously read the byte at address <code>40</code> from the EEPROM, probably checking for some bit to be set. Despite some areas being unused or unclear, this EEPROM analysis provided some valuable insights into the internal operation of the EDPW.</p><h3 class="relative group">Analyzing the firmware<div id=analyzing-the-firmware class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#analyzing-the-firmware aria-label=Anchor>#</a></span></h3><p>Returning to the PC interface, I wondered whether it might be possible to extract the microcontroller&rsquo;s firmware to reverse engineer the diagnostic protocol. As <a href=#main-components>previously noted</a>, the firmware is stored in a mask ROM during manufacturing. Gaining access to the ROM&rsquo;s contents would therefore require the chip to be decapped, which requires special equipment and practice that I don&rsquo;t have. However, according to its manual, the Mitsubishi M37451 seems to feature multiple processor modes that might allow the ROM to be dumped:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Mitsubishi M37451 processor modes" srcset="/posts/miele-interface/mcu_modes_hu_b506d915ec854d09.png 330w,
/posts/miele-interface/mcu_modes_hu_7776d48a0c109726.png 660w,
/posts/miele-interface/mcu_modes_hu_e40b9657a2456441.png 1280w" data-zoom-src=/posts/miele-interface/mcu_modes.png src=/posts/miele-interface/mcu_modes.png><figcaption>Mitsubishi M37451 processor modes</figcaption></figure></p><p>The processor is running in single-chip mode by default, as the CNV<sub>SS</sub> pin is pulled to GND on the EDPW board. Connecting CNV<sub>SS</sub> to 5 V would cause the chip to enter microprocessor mode, loading the program code from external memory. This would in theory allow the embedded firmware to be dumped, but unfortunately, access to the internal ROM is blocked in this case, as specified in the manual. This restriction, likely implemented for security reasons, is not present for the memory expansion mode, but this processor mode can only be entered by writing to a register when running in single-chip mode.</p><p>Although techniques like fault injection or voltage glitching might bypass these limitations, I decided to continue the reverse engineering process without access to the firmware.</p><h2 class="relative group">Reverse engineering the PC interface<div id=reverse-engineering-the-pc-interface class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#reverse-engineering-the-pc-interface aria-label=Anchor>#</a></span></h2><p>To communicate with the EDPW&rsquo;s optical interface, I connected a USB-UART adapter directly to the microcontroller&rsquo;s UART pins. Lacking a proper 5 V USB-UART adapter, I used an Arduino Uno clone just for its UART capabilities. As the optical interface seemed to be very sensitive to the infrared radiation of the sunlight, I decided to disconnect the phototransistor from the UART&rsquo;s receive pin:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Reverse engineering hardware setup" srcset="/posts/miele-interface/re_setup_hu_592696283237fed8.jpg 330w,
/posts/miele-interface/re_setup_hu_12e4c7c04aece638.jpg 660w,
/posts/miele-interface/re_setup_hu_227ba959960a8691.jpg 1280w" data-zoom-src=/posts/miele-interface/re_setup.jpg src=/posts/miele-interface/re_setup.jpg><figcaption>Reverse engineering hardware setup</figcaption></figure></p><p>Now that the hardware was set up, it was time to focus on the actual serial communication. As might be expected, the interface doesn&rsquo;t send any data on its own during normal operation, so its protocol must be based on a request-response scheme. However, figuring out the exact commands that need to be sent would be extremely difficult without any details about the protocol. It is often a good idea to look for similar protocols in this situation, which might provide some clues about the general command structure. After a more elaborate online search, I found a <a href=https://community.symcon.de/t/miele-home-zum-selbermachen-der-einstieg/30702 target=_blank>forum post</a> (in German) describing the <strong>Miele@home</strong> interface, which is used to add remote control functionality to Miele appliances. It provides a detailed analysis of the Miele@home communication module and its serial protocol, including a full communication log between module and appliance.</p><p>The serial interface is initially configured for a data rate of 2400 baud with 8 data bits, 1 stop bit and no parity. After a short handshake sequence, the communication switches to a speed of 9600 baud. Considering that the Miele PC interface was introduced in 1996, it doesn&rsquo;t seem unlikely that first implementations were limited to 2400 baud, which would explain why the communication begins at this baud rate. The messages sent by the module and the appliance are always either 5 bytes or 1 byte long, where a single <code>00</code> byte indicates the successful reception of a valid message by the receiving side. All 5-byte messages begin with a command byte, 2 unknown bytes and a single byte which seemingly indicates the expected length of the response payload. These messages end with a simple 8-bit checksum that is computed by summing the previous bytes, similar to the EEPROM checksum discussed in the last section.</p><p>With basic knowledge of the protocol, the first couple of messages can now be analyzed in further detail:</p><pre tabindex=0><code>Module -&gt; Appliance: 11 00 00 02 13
Appliance -&gt; Module: 00
Appliance -&gt; Module: fb 08 03
Module -&gt; Appliance: 00
Module -&gt; Appliance: 21 00 00 00 21
</code></pre><p>The handshake starts with command <code>11</code>, expecting a response with a length of <code>02</code>. The request is acknowledged by the appliance, which responds with <code>fb 08</code>. This response is likewise acknowledged by the module, which proceeds by sending the command <code>21</code>. The rest of the handshake continues in a similar manner until the communication switches to 9600 baud. <strong>Could this be the same protocol that is used by the PC interface?</strong></p><p>To confirm this assumption, I tried sending the initial <code>11</code> command via the USB-UART adapter:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Logic analyzer trace of UART signals" srcset="/posts/miele-interface/uart_trace_parity_none_hu_8e994dc302d47eb1.png 330w,
/posts/miele-interface/uart_trace_parity_none_hu_90d187757fb65dfd.png 660w,
/posts/miele-interface/uart_trace_parity_none_hu_80a459a4f490fc18.png 1280w" data-zoom-src=/posts/miele-interface/uart_trace_parity_none.png src=/posts/miele-interface/uart_trace_parity_none.png><figcaption>Logic analyzer trace of UART signals</figcaption></figure></p><p>Unfortunately, this didn&rsquo;t lead to any response from the PC interface. At this point, I decided to take another look at the microcontroller&rsquo;s datasheet, focusing on the UART section:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Mitsubishi M37451 UART operation" srcset="/posts/miele-interface/mcu_uart_hu_4d8186e5161abdcd.png 330w,
/posts/miele-interface/mcu_uart_hu_1da3bb3619efdd5e.png 660w,
/posts/miele-interface/mcu_uart_hu_f57319188e704acd.png 1280w" data-zoom-src=/posts/miele-interface/mcu_uart.png src=/posts/miele-interface/mcu_uart.png><figcaption>Mitsubishi M37451 UART operation</figcaption></figure></p><p>Assuming that the UART is indeed configured for 2400 baud, the only remaining options that can be configured are the number of data bits, stop bits and the parity mode. At this baud rate, a combination of 8 data bits and 1 stop bit would seem to be the most likely choice. However, since the communication is based on an optical interface, the parity bit might actually be used. And sure enough, configuring the USB-UART adapter for even parity and sending the same message again triggered a response from the EDPW:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="UART trace with even parity" srcset="/posts/miele-interface/uart_trace_parity_even_hu_5e67a5e32ea37d9a.png 330w,
/posts/miele-interface/uart_trace_parity_even_hu_726d24c3df9c2b12.png 660w,
/posts/miele-interface/uart_trace_parity_even_hu_7d5d51dfb663a6bc.png 1280w" data-zoom-src=/posts/miele-interface/uart_trace_parity_even.png src=/posts/miele-interface/uart_trace_parity_even.png><figcaption>UART trace with even parity</figcaption></figure></p><p>In contrast to the Miele@home communication log, the payload of the response was <code>a3 01</code> (419 in decimal) in this case. According to the technical documentation for the EDPW 206, this seems to be the so-called <strong>software ID</strong> of the board. Feeling relatively optimistic at this point, I tried transmitting the next handshake message, hoping to receive another response. However, upon sending the <code>21</code> command, the EDPW just answered with a single <code>02</code> byte. Trying other random commands also led to the same response, except for the <code>10</code> command which was acknowledged with <code>00</code>. Sending a valid message with an incorrect checksum caused the EDPW to reply with <code>01</code>.</p><p>Using a short Python script, I tested every single possible command, but none of the other commands received an acknowledgement from the EDPW. Nevertheless, even invalid commands had to be acknowledged by the PC before the EDPW would accept the next message:</p><pre tabindex=0><code>PC -&gt; EDPW: XX 00 00 02 CC
EDPW -&gt; PC: 02
PC -&gt; EDPW: 00

&lt;continue with XX + 1&gt;
</code></pre><p>At this point, the only two commands that triggered a positive response from the EDPW were <code>10</code> and <code>11</code>. While messing around with command <code>11</code>, I realized that the EDPW would not react to messages sent after this command unless the PC responded with its own 4-byte payload:</p><pre tabindex=0><code>PC -&gt; EDPW: 11 00 00 02 13
EDPW -&gt; PC: 00 a3 01 a4
PC -&gt; EDPW: 00
PC -&gt; EDPW: 00 00 00 00

&lt;next message can be sent&gt;
</code></pre><p>However, changing the values of these 4 bytes didn&rsquo;t seem to trigger another response from the EDPW. Wondering whether the handshake might require a certain sequence of commands, I modified the script to transmit command <code>11</code> before every iteration:</p><pre tabindex=0><code>PC -&gt; EDPW: 11 00 00 02 13
EDPW -&gt; PC: 00 a3 01 a4
PC -&gt; EDPW: 00
PC -&gt; EDPW: 00 00 00 00
PC -&gt; EDPW: XX 00 00 00 CC
EDPW -&gt; PC: 02
PC -&gt; EDPW: 00

&lt;continue with XX + 1&gt;
</code></pre><p>This revealed yet another valid command that was part of the handshake sequence: <code>20</code>. However, that was apparently still not enough to successfully complete the handshake process. None of the commands I tried after this point yielded any meaningful response from the EDPW. The response to command <code>20</code> was always <code>00</code>, no matter what parameter values I used for the message. After reading up on common diagnostic protocols from the 1990s, I came up with the following theory:</p><ul><li>Command <code>20</code> is used to <em>unlock</em> the diagnostic interface, but requires a certain set of parameters (a secret key)</li><li>As part of the unlock sequence, command <code>11</code> always has to be sent before <code>20</code></li><li>Upon reception of command <code>10</code>, the diagnostic interface is <em>locked</em> again</li></ul><p>But how can the secret key for the unlock command be determined? Assuming that the key is encoded in the two parameter bytes of the message, a simple brute-force approach would require up to 65536 tries to guess the key. However, without knowing whether the key was actually correctly guessed and which commands are unlocked if the correct key is provided, the total number of required attempts would increase significantly. Considering the interface&rsquo;s low speed of 2400 baud, this strategy didn&rsquo;t seem to be feasible at all.</p><h3 class="relative group">Finding a different attack vector<div id=finding-a-different-attack-vector class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#finding-a-different-attack-vector aria-label=Anchor>#</a></span></h3><p>I decided to take a closer look at the microcontroller on the EDPW board in search of other attack vectors. As <a href=#firmware-analysis>previously mentioned</a>, the Mitsubishi M37451 is configured for single-chip mode, executing its firmware directly from the internal mask ROM. However, for the two other processor modes, the M37451 provides some additional output signals which can be used to control an external EEPROM. These signals are named WR, RD, R/W and SYNC, as can be seen in the bottom right corner of the microcontroller&rsquo;s pinout:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Mitsubishi M37451 pinout" srcset="/posts/miele-interface/mcu_pinout_hu_ef633a65a78e6a2.png 330w,
/posts/miele-interface/mcu_pinout_hu_ade1e08a50bb747c.png 660w,
/posts/miele-interface/mcu_pinout_hu_43b596f3e48cfa4a.png 1280w" data-zoom-src=/posts/miele-interface/mcu_pinout.png src=/posts/miele-interface/mcu_pinout.png><figcaption>Mitsubishi M37451 pinout</figcaption></figure></p><p>According to the datasheet, the SYNC signal is high while the microcontroller is fetching an operation code from its memory. Reading from the data bus sets RD high, while writing to an external component sets WR high. The bus transfer direction is also indicated by a combined R/W signal, which is high during bus reads and low during bus writes.</p><p>One would expect these signals to be disabled when the microcontroller operates in single-chip mode, right? Well, to my surprise, attaching a logic analyzer to the SYNC pin actually showed significant activity:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Logic analyzer trace of the microcontroller&rsquo;s SYNC pin" srcset="/posts/miele-interface/sync_trace_hu_fa9f853e9e815813.png 330w,
/posts/miele-interface/sync_trace_hu_99d5c7179cfde6c2.png 660w,
/posts/miele-interface/sync_trace_hu_49d7bde68f144054.png 1280w" data-zoom-src=/posts/miele-interface/sync_trace.png src=/posts/miele-interface/sync_trace.png><figcaption>Logic analyzer trace of the microcontroller&rsquo;s SYNC pin</figcaption></figure></p><p>It turned out that all of the data bus signals are enabled, even in single-chip mode when the internal mask ROM is used. Could this SYNC signal be used to observe the program execution while receiving a diagnostic message via the PC interface? Yes, in fact the whole message processing can be seen in the logic analyzer trace:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="SYNC trace during UART reception" srcset="/posts/miele-interface/sync_trace_uart_hu_9d0eef927bf9067f.png 330w,
/posts/miele-interface/sync_trace_uart_hu_52a6b224d2224894.png 660w,
/posts/miele-interface/sync_trace_uart_hu_7758fc8e3df6ef74.png 1280w" data-zoom-src=/posts/miele-interface/sync_trace_uart.png src=/posts/miele-interface/sync_trace_uart.png><figcaption>SYNC trace during UART reception</figcaption></figure></p><p>Zooming in slightly after the stop bit shows the actual UART interrupt service routine that is being executed:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="SYNC trace during interrupt handling of a valid message" srcset="/posts/miele-interface/sync_trace_valid_message_hu_6ca01298de9a61f8.png 330w,
/posts/miele-interface/sync_trace_valid_message_hu_900912eea2dd0e9b.png 660w,
/posts/miele-interface/sync_trace_valid_message_hu_312432084a72b73d.png 1280w" data-zoom-src=/posts/miele-interface/sync_trace_valid_message.png src=/posts/miele-interface/sync_trace_valid_message.png><figcaption>SYNC trace during interrupt handling of a valid message</figcaption></figure></p><p>When sending an invalid diagnostic message instead, the microcontroller seems to return from the interrupt routine much earlier:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="SYNC pin behavior when receiving an invalid message" srcset="/posts/miele-interface/sync_trace_invalid_message_hu_70db08feb0059ac1.png 330w,
/posts/miele-interface/sync_trace_invalid_message_hu_524ee0b24e3667e1.png 660w,
/posts/miele-interface/sync_trace_invalid_message_hu_bc28f7612f94fbeb.png 1280w" data-zoom-src=/posts/miele-interface/sync_trace_invalid_message.png src=/posts/miele-interface/sync_trace_invalid_message.png><figcaption>SYNC pin behavior when receiving an invalid message</figcaption></figure></p><p>The length of the interrupt routine can therefore be used to distinguish between valid and invalid messages.</p><h3 class="relative group">Leaking the secret key<div id=leaking-the-secret-key class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#leaking-the-secret-key aria-label=Anchor>#</a></span></h3><p>With these observations in mind, it should be possible to figure out the secret parameters for the unlock command. The unlock command likely looks something like this in pseudocode:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>handle_cmd_unlock</span><span class=p>(</span><span class=n>param1</span>: <span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=n>param2</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>param1</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=no>UNLOCK_KEY1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>param2</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=no>UNLOCK_KEY2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>unlock_interface</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Therefore, guessing the correct value for the first parameter should lead to a slightly longer execution time of the interrupt routine. This same procedure can then be repeated for the second parameter, while keeping the correct value for the first parameter to discover the correct unlock message. Unlike a full brute-force approach, this approach only takes 512 tries at maximum. Each unlock attempt then consists of the following steps:</p><ol><li>Send command <code>11</code> to the PC interface as the first part of the unlock sequence</li><li>Start logic analyzer capture, triggering on the falling edge of the UART receive signal</li><li>Transmit command <code>20</code> with the chosen parameter values</li><li>Decode the recorded trace and convert the SYNC sequence into a string of 1&rsquo;s and 0&rsquo;s</li></ol><p>As before, this process is automated using a Python script and the <code>sigrok-cli</code> tool. As part of the decoding process, the script samples the SYNC signal on every falling edge of the microcontroller&rsquo;s clock output signal:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="SYNC trace with clock signal" srcset="/posts/miele-interface/sync_trace_with_clk_hu_5a0e8b8dc17c96e2.png 330w,
/posts/miele-interface/sync_trace_with_clk_hu_eb7f64d285497d6a.png 660w,
/posts/miele-interface/sync_trace_with_clk_hu_b232b0fbafd26e16.png 1280w" data-zoom-src=/posts/miele-interface/sync_trace_with_clk.png src=/posts/miele-interface/sync_trace_with_clk.png><figcaption>SYNC trace with clock signal</figcaption></figure></p><p>The recorded SYNC trace is thereby turned into a long bit string:</p><pre tabindex=0><code>10100101001010100010101000001000101000101000010000100101000100100100001000010010100010001010001001010100001010000100001010101000101010001010001010100010100010101000101000101010100101001010001000100000100101010101010010101010100010000101010001010101000100000100010001000100010100001000100101010000010010100010100010101000001001000100010100001000100000100010000010000010001000101000101000
</code></pre><p>As the microcontroller is constantly executing instructions, the actual start and end of the interrupt routine are always at a different position in the bit string. It is hard to distinguish between this routine and instructions that run before or after the actual interrupt. To find the boundaries of the routine, I defined two bit patterns that are common for every bit string:</p><pre>
Start pattern: <span class=highlight2>10100101001010100010101000</span>
End   pattern: <span class=highlight3>10000010001000101000101000</span>
</pre><p>Using these patterns, the actual <span class=highlight1>payload</span> of the SYNC trace can be determined:</p><pre>
<span class=highlight2>10100101001010100010101000</span><span class=highlight1>0010001010001010000100001001010001001001000010000100101000100010100010010101000010100001000010101010001010100010100010101000101000101010001010001010101001010010100010001000001001010101010100101010101000100001010100010101010001000001000100010001000101000010001001010100000100101000101000101010000010010001000101000010001000001000100000</span><span class=highlight3>10000010001000101000101000</span>
</pre><p>This result then allows measuring the interrupt routine&rsquo;s execution time. A change in bit stream length therefore clearly indicates a correct unlock parameter. The Python script can now be used to capture the bit strings for all possible values of the <span class=highlight4>first parameter</span>:</p><pre>
[20, <span class=highlight4>00</span>, 00, 00]: 00100...10001000101000010001000001000100000
...
[20, <span class=highlight4>eb</span>, 00, 00]: 00100...10001000101000010001000001000100000
[20, <span class=highlight4>ec</span>, 00, 00]: 00100...10001000101000010001000001000100000
[20, <span class=highlight4>ed</span>, 00, 00]: 00100...10001000101000010001000001000100000
[20, <span class=highlight4>ee</span>, 00, 00]: 00100...100010100100010001010000100010001000001000100000
[20, <span class=highlight4>ef</span>, 00, 00]: 00100...10001000101000010001000001000100000
[20, <span class=highlight4>f0</span>, 00, 00]: 00100...10001000101000010001000001000100000
[20, <span class=highlight4>f1</span>, 00, 00]: 00100...10001000101000010001000001000100000
...
[20, <span class=highlight4>ff</span>, 00, 00]: 00100...10001000101000010001000001000100000
</pre><p>And there it is: The correct first parameter seems to be <code>ee</code>. This procedure is now repeated for the <span class=highlight3>second parameter</span>:</p><pre>
[20, <span class=highlight3>ee</span>, b1, 00]: 00100...00010001010000100010001000001000100000
...
[20, <span class=highlight3>ee</span>, b1, 00]: 00100...00010001010000100010001000001000100000
[20, <span class=highlight3>ee</span>, b2, 00]: 00100...00010001010000100010001000001000100000
[20, <span class=highlight3>ee</span>, b3, 00]: 00100...00010001010000100010001000001000100000
[20, <span class=highlight3>ee</span>, b4, 00]: 00100...000101000101010100001000100010001000001000100000
[20, <span class=highlight3>ee</span>, b5, 00]: 00100...00010001010000100010001000001000100000
[20, <span class=highlight3>ee</span>, b6, 00]: 00100...00010001010000100010001000001000100000
[20, <span class=highlight3>ee</span>, b7, 00]: 00100...00010001010000100010001000001000100000
...
[20, <span class=highlight3>ee</span>, ff, 00]: 00100...00010001010000100010001000001000100000
</pre><p><strong>A few seconds later, the correct parameter combination for the unlock message is identified: <code>ee</code>, <code>b4</code>.</strong></p><h3 class="relative group">Unlocking the PC interface<div id=unlocking-the-pc-interface class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#unlocking-the-pc-interface aria-label=Anchor>#</a></span></h3><p>The full functionality of the diagnostic interface can now be enabled by completing the unlock sequence:</p><pre tabindex=0><code>PC -&gt; EDPW: 11 00 00 02 13
EDPW -&gt; PC: 00 a3 01 a4
PC -&gt; EDPW: 00
PC -&gt; EDPW: 00 00 00 00
PC -&gt; EDPW: 20 ee b4 00 c2
EDPW -&gt; PC: 00
PC -&gt; EDPW: 00
</code></pre><p>But what did this sequence actually do? Re-testing the command set reveals the presence of commands <code>30</code>, <code>31</code> and <code>32</code>, which are now successfully acknowledged by the EDPW.</p><p>While messing around with these new commands, I discovered that sending the command <code>31</code> causes the EDPW to respond with a maximum of 4 bytes, depending on the requested response length of the message. However, all returned bytes were zero, regardless of the parameter values:</p><pre tabindex=0><code>PC -&gt; EDPW: 31 00 00 04 35
EDPW -&gt; PC: 00
EDPW -&gt; PC: 00 00 00 00 00
</code></pre><p>Upon further inspection of the EDPW board, I noticed that I forgot to supply power to the EEPROM chip. Sending the command again now resulted in the following response:</p><pre tabindex=0><code>PC -&gt; EDPW: 31 00 00 04 35
EDPW -&gt; PC: 00
EDPW -&gt; PC: 00 00 0f 00 0f
</code></pre><p>Trying different parameter values resulted in varying responses from the EDPW, revealing that <strong>command <code>31</code> reads the (inverted) EEPROM data starting at the specified offset.</strong></p><p>Moving on to command <code>30</code>, I quickly noticed that its behavior closely followed the EEPROM read command. However, its response didn&rsquo;t appear to depend on the presence of the EEPROM chip. Reading the first 256 bytes using this command resulted in the following data:</p><pre>
00000000  <span class=highlight2>00 00 00 00 00 00 33 00</span>  <span class=highlight2>4f 8a 02 00 35 33 02 01</span>
00000010  <span class=highlight2>00 05 00 89 ff ff ff ff</span>  <span class=highlight2>00 08 01 07 01 ee 05 07</span>
00000020  <span class=highlight2>07 07 07 07 07 05 07 07</span>  <span class=highlight2>04 9c fe 03 02 00 00 00</span>
00000030  <span class=highlight2>44 00 00 00 00 00 0a 00</span>  <span class=highlight2>83 00 00 00 00 00 00 00</span>
00000040  <span class=highlight2>00 00 ff ff fd 00 00 f8</span>  <span class=highlight2>44 00 00 00 00 00 26 00</span>
00000050  <span class=highlight2>e3 db 4a 00 00 00 04 20</span>  <span class=highlight2>80 3f 00 00 00 30 00 00</span>
00000060  <span class=highlight2>00 00 00 00 00 00 00 00</span>  <span class=highlight2>40 00 02 00 00 00 00 00</span>
00000070  <span class=highlight2>00 00 00 00 00 00 00 00</span>  <span class=highlight2>00 00 00 00 00 00 00 00</span>
00000080  <span class=highlight2>00 00 00 00 20 00 00 00</span>  <span class=highlight2>54 01 00 00 00 00 00 00</span>
00000090  <span class=highlight2>00 ff ff 00 ff ff 00 5c</span>  <span class=highlight2>43 00 00 00 00 00 00 00</span>
000000a0  <span class=highlight2>05 20 18 00 01 00 18 00</span>  <span class=highlight2>00 ff ff 07 06 02 2c 06</span>
000000b0  <span class=highlight2>02 00 00 00 00 05 30 b4</span>  <span class=highlight2>00 10 f8 00 10 f8 00 08</span>
000000c0  <span class=highlight3>00 00 00 00 00 00 00 00</span>  <span class=highlight3>00 00 00 00 00 00 00 00</span>
000000d0  <span class=highlight4>3e ce 38 c4 00 fb b6 e9</span>  <span class=highlight4>9b 00 00 ff 02 fd 70 90</span>
000000e0  <span class=highlight4>00 00 6e 14 04 01 24 84</span>  <span class=highlight4>b8 f2 81 84 ff 00 00 03</span>
000000f0  <span class=highlight4>cc 32 c4 09 64 07 c4 09</span>  <span class=highlight4>9e 5c ff ff 00 21 e8 1c</span>
</pre><p>Hmm, could this be the internal memory of the microcontroller? To verify this, I consulted the memory map of the Mitsubishi M37451:</p><p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt="Memory map of the Mitsubishi M37451" srcset="/posts/miele-interface/mcu_memory_map_hu_f76dabf58127cb70.png 330w,
/posts/miele-interface/mcu_memory_map_hu_6ab1c2b90daa99a8.png 660w,
/posts/miele-interface/mcu_memory_map_hu_2f950a209c62e12b.png 1280w" data-zoom-src=/posts/miele-interface/mcu_memory_map.png src=/posts/miele-interface/mcu_memory_map.png><figcaption>Memory map of the Mitsubishi M37451</figcaption></figure></p><p>The area marked as <span class=highlight3>not used</span> in the diagram ranges from address <code>c0</code> to <code>cf</code>. Assuming that these bytes were zero, this would match with the response data from command <code>30</code>. Another memory area to check would be the <span class=highlight4>SFR region</span>. Knowing that the baud rate generator was configured for a baud rate of 2400, the BRG register at address <code>ea</code> would have to be set to <code>81</code>. This value could also be found in the previous response. The rest of the memory contents were part of the <span class=highlight2>RAM region</span>. <strong>This confirmed that command <code>30</code> reads memory contents based on the provided address parameters.</strong></p><h3 class="relative group">Dumping the full memory contents<div id=dumping-the-full-memory-contents class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline" href=#dumping-the-full-memory-contents aria-label=Anchor>#</a></span></h3><p>After some quick modifications to the Python script, I managed to dump the complete memory contents from the microcontroller:</p><figure><video controls preload=metadata loop muted><source src=/posts/miele-interface/memory_dumping.mp4 type=video/mp4><p>Your browser doesn't support HTML video. Here is a
<a href=/posts/miele-interface/memory_dumping.mp4 download=/posts/miele-interface/memory_dumping.mp4>link to the video</a> instead.</p></video><figcaption>Reading the Mitsubishi M37451&rsquo;s memory contents</figcaption></figure><p>This whole process took around half an hour due to the low baud rate of the PC interface. <strong>Taking a closer look at the memory dump reveals that it actually contains the full internal mask ROM contents of the microcontroller:</strong></p><pre tabindex=0><code>0000a000  1f d4 2a 90 04 2f d4 80  02 3f d4 0f d4 88 d0 f0
0000a010  60 2f d5 0f d5 ef d3 ff  d2 3f d4 1f d4 0f d4 1f
0000a020  d4 ef d2 0f d4 1f d4 2f  d4 0f d4 a0 02 20 00 a0
0000a030  a0 08 a5 4b 20 00 a0 1f  d4 60 85 4b a9 80 20 11
&lt;snip&gt;
0000ffd0  ff ff ff ff ff ff ff ff  ff ff 30 11 00 a3 01 03
0000ffe0  e9 b1 e9 b1 62 d7 43 d7  4a cd e9 b1 e9 b1 13 cd
0000fff0  d9 e2 71 b1 e9 b1 f2 b0  e9 b1 e9 b1 e9 b1 28 b4
</code></pre><p>And there you have it! <strong>A full firmware dump of the Mitsubishi M37451 on the Miele EDPW 206 board.</strong></p><p>While this blog post about the Miele PC interface protocol is far from complete, I think it&rsquo;s time to wrap things up for now. The full reverse engineering of the protocol will have to wait until next time, where I&rsquo;ll dive into a detailed analysis of the firmware.</p><p>Thanks for reading!</p></div><div class="flex author"><img class="!mt-0 !mb-0 h-24 w-24 rounded-full ltr:mr-4 rtl:ml-4" width=96 height=96 alt="Severin von Wnuck-Lipinski" src=/logo_hu_5900764391699789.png><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">Author</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Severin von Wnuck-Lipinski</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=mailto:severinvonw@outlook.de target=_blank aria-label=Email rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg>
</span></span></a><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://github.com/medusalix target=_blank aria-label=Github rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span></span></a><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://www.linkedin.com/in/severin-von-wnuck target=_blank aria-label=Linkedin rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg>
</span></span></a><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://mastodon.social/@Medusalix target=_blank aria-label=Mastodon rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg></span></span></a></div></div></div></div><div class=mb-10></div></div><script type=text/javascript src=/js/page.min.54b6f4371722649edbe871e431d8670d670878c22be8f36e229fe53cc9b786fe25a834def5e6de621f7a3e37b72bc8cd73839aa5ed907ed6cbd45cd3e1b0fa20.js integrity="sha512-VLb0NxciZJ7b6HHkMdhnDWcIeMIr6PNuIp/lPMm3hv4lqDTe9ebeYh96Pje3K8jNc4Oape2QftbL1FzT4bD6IA==" data-oid=views_posts/miele-interface/index.md data-oid-likes=likes_posts/miele-interface/index.md></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/posts/dmx-interface/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Building a Simple DMX Interface</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2019-08-26T00:00:00+02:00>26 August 2019</time>
</span></span></a></span><span></span></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex flex-col list-none sm:flex-row"><li class="flex mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href=/tags/ title=Tags>Tags</a></li></ul></nav><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2025
Severin von Wnuck-Lipinski</p><p class="text-xs text-neutral-500 dark:text-neutral-400">Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a></p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh+sCQ0E53ghYrxgYqw+0GCRyIEpA=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh] z-500" data-url=https://medusalix.github.io/><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=Search tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="Close (Esc)">
<span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>