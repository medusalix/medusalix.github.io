[{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/tags/hardware/","section":"Tags","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/tags/miele/","section":"Tags","summary":"","title":"Miele","type":"tags"},{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/tags/reverse-engineering/","section":"Tags","summary":"","title":"Reverse Engineering","type":"tags"},{"content":"A few weeks ago, my parent\u0026rsquo;s old Miele washing machine suddenly stopped functioning. It seemed like the machine finally required some maintenance, considering that it had been in operation for almost 20 years without issues. Disassembling the appliance revealed a number of hoses connecting the different parts of the washing machine. Upon closer inspection, several of these hoses were almost completely blocked by the detergent residue that had accumulated over the past two decades. After cleaning all hoses, the appliance initially seemed to be working fine again. However, at the end of the washing cycle, the machine didn\u0026rsquo;t start to spin up. According to multiple forum posts, this fault was most likely caused by the analog pressure sensor that determines the water level inside the drum. If the residual water doesn\u0026rsquo;t fall under a certain level during the pumping cycle, the machine aborts the current washing program. The white sensor housing can be easily spotted in the bottom right corner of the machine\u0026rsquo;s electronics board:\nAnalog pressure sensor mounted on PCB Following some quick measurements with a multimeter, I determined that the sensor was functioning correctly. However, as several Miele experts pointed out, the sensor might have to be calibrated again after taking the machine apart, requiring a proprietary Miele software that is only available to registered service technicians. Fortunately, it turned out that this specific problem was not related to the calibration but could be instead fixed by clearing the machine\u0026rsquo;s fault memory.\nEven though the washing machine was now working again, I was still curious about how the pressure sensor could actually be calibrated. As far as I could tell, there were no external ports on the electronics board for programming purposes. So how does the Miele software communicate with the appliance?\nThis article turned out to be much longer than initially expected. Feel free to jump to individual sections if you want to skip some of the theory! Discovering the diagnostic interface # Online repair guides and technical documentation often mention the so-called Miele Diagnostic Utility (MDU), a proprietary tool used by technicians to diagnose common faults on all kinds of Miele devices. While every official repair business can register on Miele\u0026rsquo;s website to get access to the service utility, its use requires very costly special hardware that has to be purchased from Miele and dedicated training sessions.\nAt first glance, very little information can be found online about the MDU, except for a few screenshots of the software. For illustrative purposes, I came up with the following (very rough) sketch of the graphical user interface:\nUser interface of the MDU (simplified sketch) While looking for more details of the software, I discovered this presentation (in French) about an older version of Miele\u0026rsquo;s diagnostic software and hardware, offering deeper insights into the capabilities and workings of the interface.\nDiagnostic capabilities # Judging from the contents of the presentation, the MDU can be used to read various properties from a connected appliance. This includes the software ID, model and fabrication number, operating hours and fault memory. However, the number of properties that can be queried seems to vary from model to model.\nWhile this data might be interesting for technically inclined appliance owners, the real power of the MDU lies in the monitoring features of the software. In addition to the live status of all sensors connected to the washing machine, such as the temperature sensor, water level sensor, or motor RPM, the utility also provides an overview of the actuator status, including all heating, water control and pump relays. The selected washing program and current program phase are also displayed by the software, along with the configured options, such as prewash or increased water level.\nMany Miele washing machines provide a service mode that can be accessed by turning on the machine while pressing a certain button combination on the front panel. The service options offered by this mode can also be triggered by the MDU. However, the software additionally features a calibration menu that is used to calibrate internal sensors like the analog pressure sensor that measures the water level.\nFinally, the MDU also provides program updates for Miele appliances. These updates were originally intended to allow changes to the built-in washing programs, such as adjusting program cycle times or the water amount. On newer appliances, the MDU can even update the full firmware of the electronics board.\nCommunication hardware # These features are highly useful for diagnostic purposes, not only for professional service technicians but also for appliance owners that would like to repair their own devices. But how does the MDU communicate with a Miele appliance? Reading through the presentation slides reveals a so-called Program Correction (PC) interface that is available on all appliances manufactured since 1996. This interface is located on the front panel of the machine, usually disguised as the check inlet indicator on washing machines or the salt missing indicator on dishwashers. The following picture clearly shows the PC interface on a Miele Softtronic W 2446 washing machine:\nFront panel of Miele Softtronic W 2446 washing machine While these indicator lights normally show the operating status of the machine, they are not just regular LEDs. Instead, the PC indicator LED also includes an infrared phototransistor, enabling bidirectional communication with the MDU software using a suitable optical communication adapter. According to a public Miele presentation, this interface is not only used for field diagnostics, but also during the development phase and end-of-line factory testing. The presentation also includes a picture of the actual surface-mount LED that is used on the appliance side, which looks very similar to the OSRAM Multi TOPLED SFH 7250 at first glance. While a dual-use indicator is clever in principle, it comes with drawbacks. When the respective indicator light is actually in use, no communication via the PC interface is possible. For this reason, Miele might have decided to switch to a dedicated PC LED indicator on newer appliances, such as their coffee machines. Due to the close proximity between the emitter and phototransistor, the communication is also limited to a relatively slow half-duplex operation.\nPractical use of the MDU software requires a proprietary optical communication adapter, which has to be purchased separately from Miele. This adapter, which is also referred to as the Miele Optical Interface, consists of an interface box (codename EZI 820) and a head unit (EZI 821-A) that are connected via a fiber-optic cable. The interface box features a DE-9 connector for RS-232 communication with a host PC. Newer versions of the optical interface also include a USB connector for this purpose. The head unit is then attached to the appliance through a suction cup mechanism, aligning an optical fiber with the PC indicator hole. This complete assembly and communication technique has been patented by Miele in 1995, with the original intention of allowing washing program corrections for after-sales service.\nDue to the proprietary nature of the optical interface, Miele does not publish any images of the adapter unit. However, given the high cost of official hardware, these adapters often surface on auction sites with detailed pictures. Some people are even looking to buy the MDU from other sources, as the adapter is pretty much useless without the software.\nBuilding an open source MDU # While not many details are available online about the internals of the Miele Optical Interface, this forum user claims to have bought the unit from an eBay auction. The adapter is apparently a simple serial to infrared converter, implementing the well-known Infrared Data Association (IrDA) standard, commonly used in older laptops and embedded systems. It is based on an STM32F103 microcontroller, with all upper level protocol logic implemented by the MDU software. This is excellent news, as building an adapter would therefore only require a cheap microcontroller and an infrared emitter/detector.\nIn contrast to the details about the adapter unit, the proprietary protocol that is used by the MDU software is completely undocumented. However, reverse engineering the protocol would allow an open source diagnostic software to be built, which would be immensely useful for the repair community. It might also allow older Miele appliances to be integrated into home automation solutions, by building a bridge between the PC interface and existing software such as Home Assistant.\nReverse engineering the electronics # With these goals in mind, I decided to look for salvaged electronics from old Miele appliances on eBay. More specifically, I was looking for the main circuit board of a washing machine, since experimenting on a fully assembled appliance would have posed significant electrical and mechanical hazards. As luck would have it, I managed to win the bid for a brand new Miele EDPW 206 manufactured in 2010:\nFront side of Miele EDPW 206 electronics board Back side of Miele EDPW 206 electronics board This board is part of the Miele W 961 washing machine series, manufactured from 1998 to 2003, according to this forum post. The EDPW 200 label on the back side of the PCB hints at the existence of further variations of this board for other washing machines. In contrast to newer Miele appliances, the power electronics are contained on a separate PCB for this machine, making the reverse engineering process much safer.\nThe PCB itself is a pretty simple double-layer design, without any bigger copper fills. Ground and power traces are instead routed as separate tracks, leading to the enormous number of vias that can be seen in the previous pictures. Figuring out the connections between individual components is unfortunately pretty tedious for this reason.\nKey components # One of the central components of this PCB is a large 80-pin chip marked with MIELE 6478170 M37451MC-804FP. A quick online search for M37451 suggests that this chip is part of the Mitsubishi 740 series of 8-bit microcontrollers, which are also known as MELPS 740, according to Wikipedia. These microcontrollers were originally manufactured during the 1980s and 1990s, with a relatively simple instruction set similar to the widely known WDC 65C02. Although these parts are no longer produced today, the instruction set lives on in the newer Renesas 38000/740 microcontroller series.\nThe M37451MC-804FP includes an integrated mask ROM, meaning the Miele firmware is embedded directly in the chip’s die and can\u0026rsquo;t be reprogrammed after the manufacturing process. As denoted by the MC suffix, the M37451MC-804FP has a total RAM size of 512 bytes with a 24 kB mask ROM. Other features include an 8-bit ADC with 8 channels, an 2-channel 8-bit DAC and three individual 16-bit timers. Serial communication is handled by a serial I/O block that can be configured for asynchronous or synchronous operation. The chip is powered by a 5 V supply, with an operating frequency of 10 MHz. More information about the Mitsubishi microcontrollers can be found in volume two of Mitsubishi\u0026rsquo;s Single-Chip 8-bit Microcomputers Data Book.\nMitsubishi M37451 microcontroller and Microchip 93LC66BI EEPROM Located right next to the microcontroller is a Microchip 93LC66BI EEPROM with a capacity of only 512 bytes. The stored data is organized in 16-bit words, which can be accessed via a Microwire interface. All configuration parameters and the current state of the running wash cycle are written to the EEPROM just before the machine is powered off. This allows the machine to resume the program once it is turned back on again. In addition to this data, the EEPROM also stores any program corrections that are applied via the PC interface.\nAs the water inlet, detergent processing and heating cycle are controlled by individual relays that require an input voltage higher than 5 V, the PCB also includes a Texas Instruments ULN2003A Darlington transistor array.\nThe water level inside the washing machine\u0026rsquo;s drum is sensed by an SPX3078D analog pressure sensor manufactured by Motorola. This sensor basically consists of a silicon diaphragm, which is used to determine the applied pressure through a Wheatstone bridge circuit. The differential output voltage is then processed by an ELMOS E210.01C. Since ELMOS provides no public documentation on this component, its exact function is unclear. However, I strongly assume it contains an operational amplifier and possibly additional signal processing circuitry. One of the pins is connected to the microcontroller\u0026rsquo;s analog input port and provides a voltage proportional to the sensed pressure.\nMotorola SPX3078D pressure sensor, ELMOS E210.01C IC and TI ULN2003A transistor array Most of the indicator LEDs on the PCB are multiplexed and wired to a Motorola MC14489DW LED driver, which offers an SPI interface for the microcontroller:\nMotorola MC14489DW LED driver Upon detailed inspection of the LEDs on the right side of the board, one can see that the lowest LED is quite different from the rest of the group. Looking closer reveals that this LED is actually a combined infrared emitter and phototransistor. This is the optical PC interface, disguised as one of the indicator lights:\nOptical PC interface next to normal indicator LED As noted in the communication hardware section, this part looks very similar to the OSRAM Multi TOPLED SFH 7250. The PC LED is not part of the group of multiplexed LEDs and is instead wired to a pair of transistors. An NPN transistor connects the microcontroller\u0026rsquo;s UART transmit pin to the light emitter, while the phototransistor is connected to the UART receive pin via a PNP transistor.\nThe PC interface is therefore just a simple optical UART port, albeit limited to half-duplex communication. Power-up troubles # To communicate with the EDPW board via the optical interface, the PCB has to be connected to an appropriate power supply. Luckily, the EDPW 206\u0026rsquo;s technical documentation includes the complete pinout of the board\u0026rsquo;s connectors:\nEDPW 206 connector pinout However, simply supplying the board with 5 V from a lab power supply didn\u0026rsquo;t seem to have any effect. Taking a closer look at the pinout shows that the board also expects 20 V for the UC voltage, which is connected to the ULN2003A\u0026rsquo;s common-cathode node for the integrated flyback diodes. This voltage seems to be sensed by the microcontroller through a resistive divider. Unfortunately, even with those two voltages, the EDPW didn\u0026rsquo;t seem to turn on. Further investigation revealed that the board also requires an AC zero-crossing detection signal, referred to by the term Netznulldurchgang (NND) in German. This signal is generated by an optocoupler on the power electronics board, resulting in an alternating wave based on the line frequency. Supplying a 50 Hz square wave from a Pi Pico in place of this signal finally brought the EDPW to life:\nWorking EDPW 206 board (with blinking red LEDs) While all basic functions of the EDPW seemed to work fine, including the program selection knob and the configuration buttons, I quickly noticed that the check intake and check drain indicators were flashing. Because the check intake LED also serves as the optical interface, this issue had to be resolved before any communication was possible. I initially assumed that the analog pressure sensor was giving some incorrect readings, but further investigations ruled out this theory. Instead, this issue was related to the missing relays that would normally be connected to the board. As it turns out, the microcontroller actually checks the presence of the prewash and main wash relays by sensing the voltage on the board\u0026rsquo;s relay outputs. When the relays are connected to UC on one side, the voltage at the transistor array\u0026rsquo;s collector pins is also equal to UC. Both the prewash and main wash outputs then go to a BAV70 common cathode double diode chip that is wired to the microcontroller:\nBAV70 common cathode double diode (marked as A4W) Connecting a 10 kOhm resistor between the pin for the main wash relay and UC therefore stops the red LEDs from blinking. With this workaround in place, the EDPW board was now fully functional.\nDumping the EEPROM data # Before reverse engineering the PC interface, it is worth taking a closer look at the EEPROM chip. Removing the chip from the PCB and soldering it to an SOIC adapter allows its contents to be read using a CH341A EEPROM programmer. It should be noted that the adapter can\u0026rsquo;t be plugged into the socket directly, as the pinout of the 93XXX chip differs from classic 25XXX EEPROMs that this programmer is designed for.\nAdapter PCB for SOIC EEPROM chips CH341A EEPROM and flash programmer Reading the EEPROM contents with IMSProg revealed that only 42 bytes are actually used, with almost all remaining bytes set to ff, indicating erased or unused memory:\n00000000 ff ff f0 ff ff ff cc fb b0 55 fd ff ca ce f7 db 00000010 ff ff ff d3 fd ff ff ff ff f7 fe f8 fe 11 f8 f8 00000020 f8 f8 f8 f8 f8 fa f8 f8 f8 63 ff ff ff ff ff ff 00000030 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff * 000001f0 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00 To analyze how the stored data changes under different washing program settings and conditions, the EEPROM chip was soldered to the PCB again, while also attaching a logic analyzer to monitor the Microwire interface:\nEDPW board with probes connected to EEPROM chip USB logic analyzer with 8 channels When the EDPW board is powered on, the microcontroller reads the first 42 bytes from the EEPROM. As soon as either the UC voltage or the zero-crossing signal are lost, the memory contents are written back to the EEPROM.\nEEPROM Microwire signal capture in PulseView After trying out different washing programs and observing the changes to the individual bytes, the full EEPROM contents can be deciphered:\n00000000 00 00 0f 00 00 00 33 04 4f aa 02 00 35 31 08 24 00000010 00 00 00 2c 02 00 00 00 00 08 01 07 01 ee 07 07 00000020 07 07 07 07 07 05 07 07 07 9c 00 00 00 00 00 00 00000030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 * 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff All bytes are inverted before being written to the EEPROM by the microcontroller. The first 12 bytes store general information about the washing machine. As an example, this includes the currently running program and program phase (first and second byte) and the operating hours of the appliance (third and fourth byte). This section ends with a simple one byte checksum that is computed by summing the preceding bytes (modulo ff) and inverting the result.\nThe next group of bytes encodes the fixed washing machine configuration that can only be changed by entering the programming mode. Settings such as the water type and region code are stored in this section. Another checksum is appended to these bytes, again computed over all previous bytes.\nConfiguration options that are chosen during the normal operation of the machine (e.g. short, prewash, spin cycle RPM, etc.) are preserved in the subsequent bytes, stored separately for each individual washing program.\nThe last section is mostly empty, but most likely used to further customize the behavior of washing programs as part of the program correction mechanism. Selecting the Cottons 95 °C program for example causes the microcontroller to continuously read the byte at address 40 from the EEPROM, probably checking for some bit to be set. Despite some areas being unused or unclear, this EEPROM analysis provided some valuable insights into the internal operation of the EDPW.\nAnalyzing the firmware # Returning to the PC interface, I wondered whether it might be possible to extract the microcontroller\u0026rsquo;s firmware to reverse engineer the diagnostic protocol. As previously noted, the firmware is stored in a mask ROM during manufacturing. Gaining access to the ROM\u0026rsquo;s contents would therefore require the chip to be decapped, which requires special equipment and practice that I don\u0026rsquo;t have. However, according to its manual, the Mitsubishi M37451 seems to feature multiple processor modes that might allow the ROM to be dumped:\nMitsubishi M37451 processor modes The processor is running in single-chip mode by default, as the CNVSS pin is pulled to GND on the EDPW board. Connecting CNVSS to 5 V would cause the chip to enter microprocessor mode, loading the program code from external memory. This would in theory allow the embedded firmware to be dumped, but unfortunately, access to the internal ROM is blocked in this case, as specified in the manual. This restriction, likely implemented for security reasons, is not present for the memory expansion mode, but this processor mode can only be entered by writing to a register when running in single-chip mode.\nAlthough techniques like fault injection or voltage glitching might bypass these limitations, I decided to continue the reverse engineering process without access to the firmware.\nReverse engineering the PC interface # To communicate with the EDPW\u0026rsquo;s optical interface, I connected a USB-UART adapter directly to the microcontroller\u0026rsquo;s UART pins. Lacking a proper 5 V USB-UART adapter, I used an Arduino Uno clone just for its UART capabilities. As the optical interface seemed to be very sensitive to the infrared radiation of the sunlight, I decided to disconnect the phototransistor from the UART\u0026rsquo;s receive pin:\nReverse engineering hardware setup Now that the hardware was set up, it was time to focus on the actual serial communication. As might be expected, the interface doesn\u0026rsquo;t send any data on its own during normal operation, so its protocol must be based on a request-response scheme. However, figuring out the exact commands that need to be sent would be extremely difficult without any details about the protocol. It is often a good idea to look for similar protocols in this situation, which might provide some clues about the general command structure. After a more elaborate online search, I found a forum post (in German) describing the Miele@home interface, which is used to add remote control functionality to Miele appliances. It provides a detailed analysis of the Miele@home communication module and its serial protocol, including a full communication log between module and appliance.\nThe serial interface is initially configured for a data rate of 2400 baud with 8 data bits, 1 stop bit and no parity. After a short handshake sequence, the communication switches to a speed of 9600 baud. Considering that the Miele PC interface was introduced in 1996, it doesn\u0026rsquo;t seem unlikely that first implementations were limited to 2400 baud, which would explain why the communication begins at this baud rate. The messages sent by the module and the appliance are always either 5 bytes or 1 byte long, where a single 00 byte indicates the successful reception of a valid message by the receiving side. All 5-byte messages begin with a command byte, 2 unknown bytes and a single byte which seemingly indicates the expected length of the response payload. These messages end with a simple 8-bit checksum that is computed by summing the previous bytes, similar to the EEPROM checksum discussed in the last section.\nWith basic knowledge of the protocol, the first couple of messages can now be analyzed in further detail:\nModule -\u0026gt; Appliance: 11 00 00 02 13 Appliance -\u0026gt; Module: 00 Appliance -\u0026gt; Module: fb 08 03 Module -\u0026gt; Appliance: 00 Module -\u0026gt; Appliance: 21 00 00 00 21 The handshake starts with command 11, expecting a response with a length of 02. The request is acknowledged by the appliance, which responds with fb 08. This response is likewise acknowledged by the module, which proceeds by sending the command 21. The rest of the handshake continues in a similar manner until the communication switches to 9600 baud. Could this be the same protocol that is used by the PC interface?\nTo confirm this assumption, I tried sending the initial 11 command via the USB-UART adapter:\nLogic analyzer trace of UART signals Unfortunately, this didn\u0026rsquo;t lead to any response from the PC interface. At this point, I decided to take another look at the microcontroller\u0026rsquo;s datasheet, focusing on the UART section:\nMitsubishi M37451 UART operation Assuming that the UART is indeed configured for 2400 baud, the only remaining options that can be configured are the number of data bits, stop bits and the parity mode. At this baud rate, a combination of 8 data bits and 1 stop bit would seem to be the most likely choice. However, since the communication is based on an optical interface, the parity bit might actually be used. And sure enough, configuring the USB-UART adapter for even parity and sending the same message again triggered a response from the EDPW:\nUART trace with even parity In contrast to the Miele@home communication log, the payload of the response was a3 01 (419 in decimal) in this case. According to the technical documentation for the EDPW 206, this seems to be the so-called software ID of the board. Feeling relatively optimistic at this point, I tried transmitting the next handshake message, hoping to receive another response. However, upon sending the 21 command, the EDPW just answered with a single 02 byte. Trying other random commands also led to the same response, except for the 10 command which was acknowledged with 00. Sending a valid message with an incorrect checksum caused the EDPW to reply with 01.\nUsing a short Python script, I tested every single possible command, but none of the other commands received an acknowledgement from the EDPW. Nevertheless, even invalid commands had to be acknowledged by the PC before the EDPW would accept the next message:\nPC -\u0026gt; EDPW: XX 00 00 02 CC EDPW -\u0026gt; PC: 02 PC -\u0026gt; EDPW: 00 \u0026lt;continue with XX + 1\u0026gt; At this point, the only two commands that triggered a positive response from the EDPW were 10 and 11. While messing around with command 11, I realized that the EDPW would not react to messages sent after this command unless the PC responded with its own 4-byte payload:\nPC -\u0026gt; EDPW: 11 00 00 02 13 EDPW -\u0026gt; PC: 00 a3 01 a4 PC -\u0026gt; EDPW: 00 PC -\u0026gt; EDPW: 00 00 00 00 \u0026lt;next message can be sent\u0026gt; However, changing the values of these 4 bytes didn\u0026rsquo;t seem to trigger another response from the EDPW. Wondering whether the handshake might require a certain sequence of commands, I modified the script to transmit command 11 before every iteration:\nPC -\u0026gt; EDPW: 11 00 00 02 13 EDPW -\u0026gt; PC: 00 a3 01 a4 PC -\u0026gt; EDPW: 00 PC -\u0026gt; EDPW: 00 00 00 00 PC -\u0026gt; EDPW: XX 00 00 00 CC EDPW -\u0026gt; PC: 02 PC -\u0026gt; EDPW: 00 \u0026lt;continue with XX + 1\u0026gt; This revealed yet another valid command that was part of the handshake sequence: 20. However, that was apparently still not enough to successfully complete the handshake process. None of the commands I tried after this point yielded any meaningful response from the EDPW. The response to command 20 was always 00, no matter what parameter values I used for the message. After reading up on common diagnostic protocols from the 1990s, I came up with the following theory:\nCommand 20 is used to unlock the diagnostic interface, but requires a certain set of parameters (a secret key) As part of the unlock sequence, command 11 always has to be sent before 20 Upon reception of command 10, the diagnostic interface is locked again But how can the secret key for the unlock command be determined? Assuming that the key is encoded in the two parameter bytes of the message, a simple brute-force approach would require up to 65536 tries to guess the key. However, without knowing whether the key was actually correctly guessed and which commands are unlocked if the correct key is provided, the total number of required attempts would increase significantly. Considering the interface\u0026rsquo;s low speed of 2400 baud, this strategy didn\u0026rsquo;t seem to be feasible at all.\nFinding a different attack vector # I decided to take a closer look at the microcontroller on the EDPW board in search of other attack vectors. As previously mentioned, the Mitsubishi M37451 is configured for single-chip mode, executing its firmware directly from the internal mask ROM. However, for the two other processor modes, the M37451 provides some additional output signals which can be used to control an external EEPROM. These signals are named WR, RD, R/W and SYNC, as can be seen in the bottom right corner of the microcontroller\u0026rsquo;s pinout:\nMitsubishi M37451 pinout According to the datasheet, the SYNC signal is high while the microcontroller is fetching an operation code from its memory. Reading from the data bus sets RD high, while writing to an external component sets WR high. The bus transfer direction is also indicated by a combined R/W signal, which is high during bus reads and low during bus writes.\nOne would expect these signals to be disabled when the microcontroller operates in single-chip mode, right? Well, to my surprise, attaching a logic analyzer to the SYNC pin actually showed significant activity:\nLogic analyzer trace of the microcontroller\u0026rsquo;s SYNC pin It turned out that all of the data bus signals are enabled, even in single-chip mode when the internal mask ROM is used. Could this SYNC signal be used to observe the program execution while receiving a diagnostic message via the PC interface? Yes, in fact the whole message processing can be seen in the logic analyzer trace:\nSYNC trace during UART reception Zooming in slightly after the stop bit shows the actual UART interrupt service routine that is being executed:\nSYNC trace during interrupt handling of a valid message When sending an invalid diagnostic message instead, the microcontroller seems to return from the interrupt routine much earlier:\nSYNC pin behavior when receiving an invalid message The length of the interrupt routine can therefore be used to distinguish between valid and invalid messages.\nLeaking the secret key # With these observations in mind, it should be possible to figure out the secret parameters for the unlock command. The unlock command likely looks something like this in pseudocode:\nfn handle_cmd_unlock(param1: u8, param2: u8) { if (param1 != UNLOCK_KEY1) return; if (param2 != UNLOCK_KEY2) return; unlock_interface(); } Therefore, guessing the correct value for the first parameter should lead to a slightly longer execution time of the interrupt routine. This same procedure can then be repeated for the second parameter, while keeping the correct value for the first parameter to discover the correct unlock message. Unlike a full brute-force approach, this approach only takes 512 tries at maximum. Each unlock attempt then consists of the following steps:\nSend command 11 to the PC interface as the first part of the unlock sequence Start logic analyzer capture, triggering on the falling edge of the UART receive signal Transmit command 20 with the chosen parameter values Decode the recorded trace and convert the SYNC sequence into a string of 1\u0026rsquo;s and 0\u0026rsquo;s As before, this process is automated using a Python script and the sigrok-cli tool. As part of the decoding process, the script samples the SYNC signal on every falling edge of the microcontroller\u0026rsquo;s clock output signal:\nSYNC trace with clock signal The recorded SYNC trace is thereby turned into a long bit string:\n10100101001010100010101000001000101000101000010000100101000100100100001000010010100010001010001001010100001010000100001010101000101010001010001010100010100010101000101000101010100101001010001000100000100101010101010010101010100010000101010001010101000100000100010001000100010100001000100101010000010010100010100010101000001001000100010100001000100000100010000010000010001000101000101000 As the microcontroller is constantly executing instructions, the actual start and end of the interrupt routine are always at a different position in the bit string. It is hard to distinguish between this routine and instructions that run before or after the actual interrupt. To find the boundaries of the routine, I defined two bit patterns that are common for every bit string:\nStart pattern: 10100101001010100010101000 End pattern: 10000010001000101000101000 Using these patterns, the actual payload of the SYNC trace can be determined:\n10100101001010100010101000001000101000101000010000100101000100100100001000010010100010001010001001010100001010000100001010101000101010001010001010100010100010101000101000101010100101001010001000100000100101010101010010101010100010000101010001010101000100000100010001000100010100001000100101010000010010100010100010101000001001000100010100001000100000100010000010000010001000101000101000 This result then allows measuring the interrupt routine\u0026rsquo;s execution time. A change in bit stream length therefore clearly indicates a correct unlock parameter. The Python script can now be used to capture the bit strings for all possible values of the first parameter:\n[20, 00, 00, 00]: 00100...10001000101000010001000001000100000 ... [20, eb, 00, 00]: 00100...10001000101000010001000001000100000 [20, ec, 00, 00]: 00100...10001000101000010001000001000100000 [20, ed, 00, 00]: 00100...10001000101000010001000001000100000 [20, ee, 00, 00]: 00100...100010100100010001010000100010001000001000100000 [20, ef, 00, 00]: 00100...10001000101000010001000001000100000 [20, f0, 00, 00]: 00100...10001000101000010001000001000100000 [20, f1, 00, 00]: 00100...10001000101000010001000001000100000 ... [20, ff, 00, 00]: 00100...10001000101000010001000001000100000 And there it is: The correct first parameter seems to be ee. This procedure is now repeated for the second parameter:\n[20, ee, b1, 00]: 00100...00010001010000100010001000001000100000 ... [20, ee, b1, 00]: 00100...00010001010000100010001000001000100000 [20, ee, b2, 00]: 00100...00010001010000100010001000001000100000 [20, ee, b3, 00]: 00100...00010001010000100010001000001000100000 [20, ee, b4, 00]: 00100...000101000101010100001000100010001000001000100000 [20, ee, b5, 00]: 00100...00010001010000100010001000001000100000 [20, ee, b6, 00]: 00100...00010001010000100010001000001000100000 [20, ee, b7, 00]: 00100...00010001010000100010001000001000100000 ... [20, ee, ff, 00]: 00100...00010001010000100010001000001000100000 A few seconds later, the correct parameter combination for the unlock message is identified: ee, b4.\nUnlocking the PC interface # The full functionality of the diagnostic interface can now be enabled by completing the unlock sequence:\nPC -\u0026gt; EDPW: 11 00 00 02 13 EDPW -\u0026gt; PC: 00 a3 01 a4 PC -\u0026gt; EDPW: 00 PC -\u0026gt; EDPW: 00 00 00 00 PC -\u0026gt; EDPW: 20 ee b4 00 c2 EDPW -\u0026gt; PC: 00 PC -\u0026gt; EDPW: 00 But what did this sequence actually do? Re-testing the command set reveals the presence of commands 30, 31 and 32, which are now successfully acknowledged by the EDPW.\nWhile messing around with these new commands, I discovered that sending the command 31 causes the EDPW to respond with a maximum of 4 bytes, depending on the requested response length of the message. However, all returned bytes were zero, regardless of the parameter values:\nPC -\u0026gt; EDPW: 31 00 00 04 35 EDPW -\u0026gt; PC: 00 EDPW -\u0026gt; PC: 00 00 00 00 00 Upon further inspection of the EDPW board, I noticed that I forgot to supply power to the EEPROM chip. Sending the command again now resulted in the following response:\nPC -\u0026gt; EDPW: 31 00 00 04 35 EDPW -\u0026gt; PC: 00 EDPW -\u0026gt; PC: 00 00 0f 00 0f Trying different parameter values resulted in varying responses from the EDPW, revealing that command 31 reads the (inverted) EEPROM data starting at the specified offset.\nMoving on to command 30, I quickly noticed that its behavior closely followed the EEPROM read command. However, its response didn\u0026rsquo;t appear to depend on the presence of the EEPROM chip. Reading the first 256 bytes using this command resulted in the following data:\n00000000 00 00 00 00 00 00 33 00 4f 8a 02 00 35 33 02 01 00000010 00 05 00 89 ff ff ff ff 00 08 01 07 01 ee 05 07 00000020 07 07 07 07 07 05 07 07 04 9c fe 03 02 00 00 00 00000030 44 00 00 00 00 00 0a 00 83 00 00 00 00 00 00 00 00000040 00 00 ff ff fd 00 00 f8 44 00 00 00 00 00 26 00 00000050 e3 db 4a 00 00 00 04 20 80 3f 00 00 00 30 00 00 00000060 00 00 00 00 00 00 00 00 40 00 02 00 00 00 00 00 00000070 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00000080 00 00 00 00 20 00 00 00 54 01 00 00 00 00 00 00 00000090 00 ff ff 00 ff ff 00 5c 43 00 00 00 00 00 00 00 000000a0 05 20 18 00 01 00 18 00 00 ff ff 07 06 02 2c 06 000000b0 02 00 00 00 00 05 30 b4 00 10 f8 00 10 f8 00 08 000000c0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000000d0 3e ce 38 c4 00 fb b6 e9 9b 00 00 ff 02 fd 70 90 000000e0 00 00 6e 14 04 01 24 84 b8 f2 81 84 ff 00 00 03 000000f0 cc 32 c4 09 64 07 c4 09 9e 5c ff ff 00 21 e8 1c Hmm, could this be the internal memory of the microcontroller? To verify this, I consulted the memory map of the Mitsubishi M37451:\nMemory map of the Mitsubishi M37451 The area marked as not used in the diagram ranges from address c0 to cf. Assuming that these bytes were zero, this would match with the response data from command 30. Another memory area to check would be the SFR region. Knowing that the baud rate generator was configured for a baud rate of 2400, the BRG register at address ea would have to be set to 81. This value could also be found in the previous response. The rest of the memory contents were part of the RAM region. This confirmed that command 30 reads memory contents based on the provided address parameters.\nDumping the full memory contents # After some quick modifications to the Python script, I managed to dump the complete memory contents from the microcontroller:\nYour browser doesn't support HTML video. Here is a link to the video instead. Reading the Mitsubishi M37451\u0026rsquo;s memory contents This whole process took around half an hour due to the low baud rate of the PC interface. Taking a closer look at the memory dump reveals that it actually contains the full internal mask ROM contents of the microcontroller:\n0000a000 1f d4 2a 90 04 2f d4 80 02 3f d4 0f d4 88 d0 f0 0000a010 60 2f d5 0f d5 ef d3 ff d2 3f d4 1f d4 0f d4 1f 0000a020 d4 ef d2 0f d4 1f d4 2f d4 0f d4 a0 02 20 00 a0 0000a030 a0 08 a5 4b 20 00 a0 1f d4 60 85 4b a9 80 20 11 \u0026lt;snip\u0026gt; 0000ffd0 ff ff ff ff ff ff ff ff ff ff 30 11 00 a3 01 03 0000ffe0 e9 b1 e9 b1 62 d7 43 d7 4a cd e9 b1 e9 b1 13 cd 0000fff0 d9 e2 71 b1 e9 b1 f2 b0 e9 b1 e9 b1 e9 b1 28 b4 And there you have it! A full firmware dump of the Mitsubishi M37451 on the Miele EDPW 206 board.\nWhile this blog post about the Miele PC interface protocol is far from complete, I think it\u0026rsquo;s time to wrap things up for now. The full reverse engineering of the protocol will have to wait until next time, where I\u0026rsquo;ll dive into a detailed analysis of the firmware.\nThanks for reading!\n","date":"17 July 2025","externalUrl":null,"permalink":"/posts/miele-interface/","section":"Posts","summary":"","title":"Reverse Engineering the Miele Diagnostic Interface","type":"posts"},{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/","section":"Severin's Blog","summary":"","title":"Severin's Blog","type":"page"},{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"When I first joined the sound-and-lights team at my school, I was quite impressed by the amount of technical equipment they had. While I enjoyed sitting in front of the mixing console and setting up all the microphones and speakers, it was always the lights which caught my attention. We had twelve theater lights mounted on two crossbars with different colored filters in front of them. All those lights were powered by a small 24 channel DMX controller. Due to the powerful lamps we used (up to 1000 watts), turning on the lights regularly tripped the breaker. That\u0026rsquo;s why we had to use two separate 16 amp phases only to power the lights and a single one for the amplifiers (which also helped with the noise induced by the DMX light dimmers). I was always interested in computer-controlled stuff, so the natural thing for me was to look up how to control these lights with a PC. When I read about DMX interfaces and how they essentially only consist of a USB-to-UART and a RS-485 driver, I knew what my next project would look like.\nHow it works # The basic principle of a DMX interface is pretty simple. Your PC sends out raw DMX frames over the USB interface, which are turned into serial data by a USB to UART chip. That data is passed onto a RS-485 driver that outputs differential signals. The DMX devices receive the signals with another RS-485 transceiver and their microcontroller uses the serial data to turn the lights on and off. The differential signaling used by RS-485 helps to reduce interference caused by noise and other cables running next to your DMX line.\nI added some additional protection to prevent the USB ports from being fried by plugging in a faulty DMX device into your interface (some dodgy Chinese fog machines use XLR for their power supply, possibly putting mains voltage on your DMX bus). The necessary isolation is done using a DC-to-DC converter and an optocoupler for the data line.\nThe main components of the circuit First prototype # The first experiments were done on a breadboard, but I quickly moved to more permanent prototype boards. I decided to integrate two independent DMX outputs to support more flexible routing options (like sitting in the middle of two DMX lights) and for an increased fail-safety. For the USB to UART conversion I chose a simple FT232 breakout board to help with soldering.\nMost of the components placed on the board I like to do the connections between parts with very thin wires. The insulation burns off when touched with a soldering iron, making the soldering very easy and quick. I built many devices that way and the wiring has proven to be very reliable.\nLots of ultra thin wires on the backside I used the following parts for this build:\nMaxim MAX485 (line driver) Vishay 6N137 (optocoupler) Mornsun B0505S-1W (DC-DC converter) FTDI FT232 (USB-UART converter) 120 Ω DMX termination resistor Current limiting resistor for the optocoupler Two capacitors for the DC-DC converter All of the components are very cheap and readily available from Ebay or Aliexpress. The whole cost of this project was around €10-15 (the most expensive part being the enclosure).\nFinal build # The assembled board was placed into a nice plastic enclosure, with two XLR jacks on one side and a USB type B connector on the other. Whether you choose good-quality Neutrik XLR sockets or some no-name Chinese ones is up to you. If you want to stick to the DMX specification you can of course also use the 5-pin versions. The USB jack was soldered to some copper angle brackets and screwed into the side. A simple mini USB cable with one end cut off was used to connect to the UART board.\nThe final board in its enclosure (one DC-DC converter is still missing) The interface can be used with a whole range of software, such as DMXControl or Lightkey. The performance of the interface is limited by the power of your computer, because no internal buffering is done (this would require a microcontroller). Though any PC built in the last ten years should work just fine. I never had problems with dropouts or lights misbehaving.\nThe project was very fun to plan and build and enabled us to program some fancy light-effects and transitions. A few months later, the school decided to buy new LED lamps and a better lighting desk. Quite unfortunately, I didn\u0026rsquo;t have a chance to try out their new RGB lights with my interface because I already left school a few weeks after.\nParty for the younger students, controlled using Lightkey ","date":"26 August 2019","externalUrl":null,"permalink":"/posts/dmx-interface/","section":"Posts","summary":"","title":"Building a Simple DMX Interface","type":"posts"},{"content":"","date":"26 August 2019","externalUrl":null,"permalink":"/tags/diy/","section":"Tags","summary":"","title":"DIY","type":"tags"},{"content":"","date":"26 August 2019","externalUrl":null,"permalink":"/tags/dmx/","section":"Tags","summary":"","title":"DMX","type":"tags"},{"content":"","date":"26 August 2019","externalUrl":null,"permalink":"/tags/lighting/","section":"Tags","summary":"","title":"Lighting","type":"tags"}]